--- lib/modernish/mdl/safe.mm	2019-12-31 16:32:42.000000000 +0000
+++ lib/modernish/mdl/safe.mm	2020-02-09 01:42:44.000000000 +0000
@@ -17,12 +17,6 @@
 # which help make working in this mode practical and straightforward. No
 # more quoting, split or glob headaches!
 #
-# For interactive shells (or if 'use safe' is given the '-i' option), there
-# are the 'fsplit' and 'glob' functions for convenient control of field
-# splitting and globbing from the command line. For shell programs to
-# temporarily enable these, it's recommended to use var/local instead;
-# see there for documentation.
-#
 # Note: as long as zsh 5.0.8 remains supported, authors of portable scripts
 # should take note of BUG_APPENDC: the `>>` appending output redirection
 # operator does not create a file but errors out if it doesn't already exist.
@@ -51,11 +45,10 @@
 # --- end license ---
 
 # ------------
-unset -v _Msh_safe_i _Msh_safe_k
+unset -v _Msh_safe_k
 shift	# abandon $1 = module name
 while let "$#"; do
 	case $1 in
-	( -i )	_Msh_safe_i=y;;
 	( -k )	_Msh_safe_k=y ;;
 	( -K )	_Msh_safe_k=Y ;;
 	( -[!-]?* ) # split a set of combined options
@@ -127,130 +120,3 @@
 	esac
 fi
 
-# --- A couple of convenience functions for field splitting and globbing ---
-# Primarily convenient for interactive shells. To load these in shell
-# scripts, add the -i option to 'use safe'. However, for shell scripts,
-# LOCAL...BEGIN...END blocks are recommended instead (see var/local.mm).
-
-if isset -i || isset _Msh_safe_i; then
-
-	if not isset _Msh_safe_i; then
-		putln >&2 "NOTE: the safe mode is designed to eliminate quoting hell for scripts, but may" \
-			"be inconvenient to use on interactive shells. Field splitting and globbing are" \
-			"now disabled. Be aware that something like 'ls *.txt' now will not work by" \
-			"default. However, two extra functions are available in interactive safe mode:" \
-			"  - fsplit {on,off,set CHARS,save,restore,show}" \
-			"  - glob {on,off,save,restore,show}" \
-			"Using (subshells) is a recommended technique for interactive safe mode, e.g.:" \
-			"	(glob on; ls *.txt)" \
-			"[To disable this warning, add the '-i' option to 'use safe'.]"
-	else
-		unset -v _Msh_safe_i
-	fi
-
-	# fsplit:
-	# Turn field splitting on (to default space+tab+newline), or off, or turn it
-	# on with specified characters. Use the modernish CC* constants to
-	# represent control characters. For an example of the latter, the default is
-	# represented with the command:
-	#
-	#	fsplit set " ${CCt}${CCn}" # space, tab, newline
-	#
-	# Ref.: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_05
-	#	1. If the value of IFS is a <space>, <tab>, and <newline>, ***OR IF
-	#	   IT IS UNSET***, any sequence of <space>, <tab>, or <newline>
-	#	   characters at the beginning or end of the input shall be ignored
-	#	   and any sequence of those characters within the input shall
-	#	   delimit a field.
-	#	2. If the value of IFS is null, no field splitting shall be performed.
-	#
-	# 'fsplit save' and 'fsplit restore' use the stack functions
-	# above to gain multiple levels of save and restore; this allows safe use in
-	# functions, loops, and recursion. We have to save/restore not just the
-	# value, but also the set/unset state, because this determines whether field
-	# splitting is active at all. The stack functions do this.
-
-	fsplit() {
-		if let "$# == 0"; then
-			set -- 'show'
-		fi
-		while let "$#"; do
-			case "$1" in
-			( 'on' )
-				IFS=" ${CCt}${CCn}"
-				;;
-			( 'off' )
-				IFS=''
-				;;
-			( 'set' )
-				shift
-				let "$#" || die "fsplit set: argument expected"
-				IFS="$1"
-				;;
-			( 'save' )
-				push IFS
-				;;
-			( 'restore' )
-				pop IFS || die "fsplit restore: stack empty"
-				;;
-			( 'show' )
-				if not isset IFS || str eq "$IFS" " ${CCt}${CCn}"; then
-					putln "field splitting is active with default separators:" \
-					      "  20  09  0a" \
-					      "      \t  \n"
-				elif str empty "$IFS"; then
-					putln "field splitting is not active"
-				else
-					putln "field splitting is active with custom separators:"
-					put "$IFS" | od -v -An -tx1 -c || die "fsplit: 'od' failed"
-				fi
-				# TODO: show field splitting settings saved on the stack, if any
-				;;
-			( * )
-				die "fsplit: invalid argument: $1"
-				;;
-			esac
-			shift
-		done
-	}
-
-	# Turn globbing (a.k.a. pathname expansion) on or off.
-	#
-	# 'glob save' and 'glob restore' use a stack to gain multiple levels
-	# of save and restore; this allows safe use in functions, loops, and
-	# recursion.
-
-	glob() {
-		if let "$# == 0"; then
-			set -- 'show'
-		fi
-		while let "$#"; do
-			case "$1" in
-			( 'on' )
-				set +f
-				;;
-			( 'off' )
-				set -f
-				;;
-			( 'save' )
-				push -f
-				;;
-			( 'restore' )
-				pop -f || die "glob restore: stack empty"
-				;;
-			( 'show' )
-				if isset -f
-				then putln "pathname expansion is not active"
-				else putln "pathname expansion is active"
-				fi
-				# TODO: show glob settings saved on the stack, if any
-				;;
-			( * )
-				die "glob: invalid argument: $1"
-				;;
-			esac
-			shift
-		done
-	}
-
-fi
