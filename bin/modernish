#! /bin/sh

# modernish - a cross-platform POSIX shell modernizer library.
#
# Goals:
# 1. realise the POSIX promise of "write once, adopt everywhere" for the shell
# 2. fix frequent shell language pitfalls and annoyances
# 3. extend the shell language with useful features
#
# POSIX reference: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/contents.html
#
# --- begin license ---
# Copyright (c) 2019 Martijn Dekker <martijn@inlv.org>, Groningen, Netherlands
# 
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
# 
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
# --- end license ---

# -------------

case ${MSH_VERSION+s} in
( s )	if ! { (unset -v MSH_VERSION) 2>|/dev/null && unset -v MSH_VERSION; }; then
		case $MSH_VERSION in
		( failedinit )	echo 'Initialisation has previously failed. Try another shell.' 1>&2 ;;
		( * )		echo 'Already initialised. To reload modernish, exit this shell first.' 1>&2 ;;
		esac
		case $- in
		( *i* )	return 124 ;;
		esac
		\exit 124
	fi ;;
esac >|/dev/null || {
	echo 'modernish does not run on restricted shells.' 1>&2
	\exit 124
}

# -------------

# Initialization, phase 1.

# It is possible to initialise modernish in a ( subshell environment ), e.g. for testing purposes. On AT&T
# ksh93, subshells are normally handled specially without forking a new process. However, ksh93 bugs cause
# various things leak out of the subshell into the main shell, preventing proper init in the main shell
# later. To avoid these bugs, now force the forking of a real subshell process by issuing a 'ulimit' command.
case ${KSH_VERSION-} in
( Version* )	let .sh.subshell && ulimit -t unlimited 2>/dev/null ;;
esac

# Modernish does _not_ support -e (-o errexit).
set +e

# Save and turn off 'allexport' to avoid exporting internal variables.
case $- in
( *a* )	set +a; _Msh_allexport=y ;;
( * )	unset -v _Msh_allexport ;;
esac

# Set default system $PATH, a path guaranteed to find standard POSIX utilities.
# Note: 'command -p' is broken on far too many shells. Instead, use something like
#	PATH=$DEFPATH command id -u
DEFPATH=${DEFPATH:-$(PATH=/usr/xpg6/bin:/usr/xpg4/bin:/bin:/usr/bin:$PATH \getconf PATH 2>/dev/null)} || DEFPATH=/bin:/usr/bin:/sbin:/usr/sbin  # this line will be changed by install.sh
readonly DEFPATH

# The version and location of modernish.
MSH_VERSION=0.12.0dev
MSH_SHELL=${MSH_SHELL:-$(PATH=$DEFPATH sh -c 'command -v sh || which sh || echo /bin/sh')}
MSH_PREFIX=${srcdir:-$PWD}		# this line and the previous will be changed by install.sh
MSH_CONFIG=${XDG_CONFIG_HOME:-~/.config}/modernish

# Internal function for aborting initialisation.
# Usage: _Msh_initExit "error message"
_Msh_initExit() {
	PATH=$DEFPATH
	case ${MSH_IGNORE_FATAL_BUGS+s} in
	( s )	printf 'modernish: %s\n' "$@" "Continuing anyway. THINGS WILL BREAK." 1>&2
		PATH=/dev/null
		return 0 ;;
	esac
	printf 'modernish: %s\n' "$@" "Initialisation failed. Aborting." 1>&2
	MSH_VERSION=failedinit
	readonly MSH_VERSION
	case $- in
	( *i* )	# try not to exit an interactive shell
		PATH=${_Msh_PATH}
		case ${_Msh_IFS+s} in
		( s )	IFS=${_Msh_IFS} ;;
		( * )	unset -v IFS ;;
		esac
		kill -INT "$$" || kill -s INT "$$" ;;
	esac 2>|/dev/null
	\exit 124
}

# Do the entire initialisation with PATH=/dev/null, so we can test for builtins without external commands interfering.
# Don't use regular builtins (e.g. 'test'/'[') without PATH=$DEFPATH, or yash in POSIX mode won't find them.
_Msh_PATH=$PATH
PATH=/dev/null

# Save IFS (including its value and whether it is set or unset) to restore it at the end of initialisation.
# Due to BUG_IFSISSET on ksh93, we can't test if IFS is set by any normal method, and we also can't know yet if we're on ksh93
# or not. So use the workaround here, which is to analyse field splitting behaviour (this thankfully works on all shells).
_Msh_testFn() {
	case ${IFS:+n} in	# non-empty: it is set
	( '' )	set -- "a b c"	# empty: test for default field splitting
		set -- $1
		case $# in
		( 1 )	;;	# no field splitting: it is empty and set
		( * )	! : ;;	# default field splitting: it is unset
		esac ;;
	esac
}
_Msh_testFn && _Msh_IFS=$IFS || unset -v _Msh_IFS

# Remove all aliases from the execution environment, as some shells set
# unhelpful default aliases. (Particularly, AT&T ksh sets
#	alias command="command "
# which defeats the ability of 'command' to bypass aliases, which would break
# feature testing using the "thisshellhas" function).
# On interactive shells, only remove certain aliases that would definitely
# interfere, to avoid undoing system or user profile settings.
unset -v _Msh_FTL_UNALIASA
case $- in
( *i* )	\unalias command exec alias unalias set unset exit return eval \
		echo kill printf test showusage \
		@ROFUNC@	# install.sh will replace this tag
	;;
( * )	\unalias -a || _Msh_FTL_UNALIASA=y ;;
esac 2>| /dev/null

# _Msh_cap (capabilities; also quirks and bugs) is space-separated. Each ID in
# ${_Msh_cap} should only contain ASCII capital letters A-Z, digits 0-9, and (for
# bugs or quirks) the underscore. Maximum length per ID is 13 characters.
unset -v _Msh_cap	# unexport, just in case
_Msh_cap=''

# Helper variable and function.
_Msh_ftlcount=0
_Msh_have() {
	_Msh_cap=${_Msh_cap:+${_Msh_cap} }$1
	case $1 in
	( FTL_* )
		PATH=$DEFPATH printf \
			'[%s]\t%s\n' "$1" "$2" 1>&2		# Formats well if $1 is max 13 chars
		_Msh_ftlcount=$(( ${_Msh_ftlcount} + 1 ))	# FTL_NOARITH compatible addition
		;;
	esac
}

# Request standards compliance.

# ... first, a sanity check
case \
${BASH_VERSION+s}\
${KSH_VERSION+s}\
${NETBSD_SHELL+s}\
${POSH_VERSION+s}\
${SH_VERSION+s}\
${YASH_VERSION+s}\
${ZSH_VERSION+s}\
 in
( s )	;;
( '' )	command set -o posix 2>/dev/null ;;	# Try if a non-identifiable shell has a POSIX option
( * )	_Msh_initExit "sanity check failed: more than one shell version identifier variable found" ;;
esac

# ... on non-interactive shells, turn off brace expansion by default, if it exists
case $- in
( *i* )	;;
( * )	_Msh_testFn() {
		command set +o braceexpand 2>/dev/null
		# FTL_CMDPP: bosh (schilytools sh) 2018-03-01
		case $#,${1-},${2-},${3-} in
		( 3,a,b,c ) ;;
		( * )	_Msh_have FTL_CMDPP "Error in 'command set ...' overwrites positional parameters." ;;
		esac
	}
	_Msh_testFn a b c ;;
esac

# ... zsh:
#	Note: zsh has more reserved words than other shells, so these are
#	not usable for function names, including:
#		declare end float foreach integer local nocorrect repeat
#	If you need one or more of these names, use something like:
#		isset ZSH_VERSION && disable -r repeat
case ${ZSH_VERSION+z} in
( z )	case $- in
	( *x* )	emulate -R sh; set -x ;;
	( * )	emulate -R sh ;;
	esac
	# We need POSIX_ARGZERO for correct initialisation in phase 2.
	setopt POSIX_ARGZERO
	# Enable UTF-8 support if we're in such a locale.
	setopt MULTIBYTE 2>/dev/null
	# FTL_FLOWCORR: Program flow corruption if a subshell exits due to an error.
	# Due to the nature of the bug, this must be tested using a helper dot
	# script. See that file for details. (zsh on Solaris 11.3)
	. "$MSH_PREFIX/libexec/modernish/cap/aux/FTL_FLOWCORR.t" \
	&& _Msh_have FTL_FLOWCORR "Program flow corruption if a subshell exits due to an error."
	# On zsh < 5.3, "readonly" works like "typeset -r" even in POSIX mode,
	# meaning readonly variables set in functions are local to functions,
	# which is contrary to our usage and POSIX. Test for that bug and make
	# "readonly" do "typeset -rg" if found, making them global.
	# TODO: remove when we stop supporting zsh < 5.3
	unset -v _Msh_RO
	_Msh_testFn() {
		readonly _Msh_RO=y
	}
	_Msh_testFn
	case ${_Msh_RO-} in
	( y )	unsetopt POSIX_BUILTINS	# allow 'typeset +r'
		typeset +r _Msh_RO
		setopt POSIX_BUILTINS
		unset -v _Msh_RO ;;
	( * )	disable -r readonly 2>/dev/null	# it's a reserved word on zsh 5.2
		disable readonly
		eval 'function readonly { typeset -rg "$@"; }'
		alias readonly='typeset -rg' ;;
		# In stage 2 init at the end, we'll redefine this alias to be
		# properly conditional upon posixbuiltins. Not doing this now
		# as it comes at the cost of forking a subshell and
		# modernish init doesn't need it.
	esac
	if ! unset -f _Msh_nonexistent_fn 2>/dev/null; then
		# 'unset -f' complains about nonexistent functions (contra POSIX);
		# make it quietly accept them like other shells.
		# TODO: remove when we stop supporing zsh < 5.5
		eval 'function unset {
			case $1 in
			( -f )  builtin unset "$@" 2>/dev/null || : ;;
			( * )	builtin unset "$@" ;;
			esac
		}'
	fi
	# Make zsh even more POSIXy for cross-shell scripts only.
	case $0 in
	( modernish | */modernish )
		# These zsh-specific reserved words may interfere with shell functions.
		disable -r end foreach nocorrect repeat 2>/dev/null
		# These revert to builtins, subject to KSH_TYPESET, which is off by default for sh.
		disable -r declare export float integer local readonly typeset 2>/dev/null
		# Counting line numbers of 'eval' commands is more in line with other shells.
		setopt EVAL_LINENO
		;;
	esac
	;;
esac

# ... pdksh and derivatives (oksh, mksh, lksh, ... ?)
case ${KSH_VERSION:-${SH_VERSION:-}} in
( '@(#)'* )
	set -o posix
	# mksh/lksh have UTF-8 support as of R38, but it needs to be turned on
	# explicitly with 'set -U'; the locale is not detected for scripts,
	# presumably for backwards compatibility with OpenBSD which only
	# supports ASCII. The recipe below is recommended by mksh's man page.
	case ${KSH_VERSION:-} in
	( '@(#)MIRBSD KSH '* | '@(#)LEGACY KSH '* )
		case ${LC_ALL:-${LC_CTYPE:-${LANG:-}}} in
		( *[Uu][Tt][Ff]8* | *[Uu][Tt][Ff]-8* )
			set -U ;;
		( * )	set +U ;;
		esac ;;
	esac ;;
esac

# ... yash: it's very POSIX compliant even without posix mode, but unlike in
# other shells, posix mode disables non-standard functionality that scripts
# might want to test for and use (e.g. local variables, floating point arith).
# Yash in posix mode is also the only shell that honours the POSIX requirement
# that regular built-in utililities must have an existing external equivalent
# in order to be executed. This means that, in posix mode, yash will search
# $PATH before each execution of any regular built-in, which severely impacts
# performance.
# For these two reasons, perhaps it's better to leave posix mode off for yash.
# However, for compatibility testing purposes, it's very useful to turn it on,
# because it's the strictest POSIX compliance check available.
#case ${YASH_VERSION+s} in ( s ) set -o posix ;; esac

# ... NetBSD sh:
case ${NETBSD_SHELL+n} in
( n )	set -o posix ;;
esac

# ... external commands:
export POSIXLY_CORRECT=y	# this also sets -o posix on bash

# --- end of standards compliance requests ---

# -------------

# If PS4 is default, set a useful PS4 for xtrace (set -x) output.
# Modernish has a *lot* of shell code so this is quite indispensable.
# Depending on the shell, trace:
#  - current time, or time elapsed -- with precision if available
#  - either subshell PID (P) or subshell level (S)
#  - current file (last 2 pathname elements)
#  - current shell function
#  - line number (L)
#  - the previous command's exit status (e)
case ${PS4-} in
( "+ " | "+%N:%i> " )
	# The ${foo#{foo%/*/*}/} substitutions below are to trace just the last two
	# elements of path names, instead of the full paths which can be very long.
	case ${ZSH_VERSION:+Zsh}${NETBSD_SHELL:+Netsh}${KSH_VERSION:+Ksh}${BASH_VERSION:+Bash} in
	(Zsh)	typeset -F SECONDS
		PS4='+ [${SECONDS:+${SECONDS%????}s|}${ZSH_SUBSHELL:+S$ZSH_SUBSHELL,}${funcfiletrace:+${funcfiletrace#${funcfiletrace%/*/*}/},}${funcstack:+${funcstack#${funcstack%/*/*}/},}${LINENO:+L$LINENO,}e$?] ' ;;
	(Netsh)	PS4='+ [${ToD:+$ToD|}${LINENO:+L$LINENO,}e$?] ' ;;
	(Ksh)	case $KSH_VERSION in
		(Vers*)	typeset -F SECONDS
			PS4='+ [${SECONDS:+${SECONDS%????}s|}${.sh.subshell:+S${.sh.subshell},}${.sh.file:+${.sh.file#${.sh.file%/*/*}/},}${.sh.fun:+${.sh.fun},}${LINENO:+L$LINENO,}e$?] ' ;;
		(@\(*)	PS4='+ [${EPOCHREALTIME:+${EPOCHREALTIME#???????}s|}${BASHPID:+P$BASHPID,}${LINENO:+L$LINENO,}e$?] ' ;;
		esac ;;
	(Bash)	case ${EPOCHREALTIME:+s} in
		(s)	PS4='+ [${EPOCHREALTIME:+${EPOCHREALTIME#???????}s|}' ;;
		('')	PS4='+ [${SECONDS:+${SECONDS}s|}' ;;
		esac
		PS4=$PS4'${BASHPID:+P$BASHPID,}${BASH_SOURCE:+${BASH_SOURCE#${BASH_SOURCE%/*/*}/},}${FUNCNAME:+$FUNCNAME,}${LINENO:+L$LINENO,}e$?] ' ;;
	('')	case ${SECONDS:+s} in
		(s)	PS4='+ [${SECONDS:+${SECONDS}s|}${LINENO:+L$LINENO,}e$?] ' ;;
		('')	PS4='+ [${LINENO:+L$LINENO,}e$?] ' ;;
		esac ;;
	esac ;;
esac

# -------------

# --- Built-in shell feature, quirk, bug and POSIX compliance requirement checks ---
# Block on fatal shell bugs and standards incompatibilities that would break
# modernish. Identify quirks and nonstandard features. As a side effect,
# also do some of the initialization.
#
# NOTE: all tests need to be compatible with all the bugs tested for (even
# the fatal ones), so that modernish can give a full report.

# FTL_NOALIAS: No aliases (Debian posh; bash "minimal configuration").
alias test=test 2>|/dev/null || _Msh_have FTL_NOALIAS 'No support for aliases at all.'
unalias test 2>|/dev/null	# AT&T ksh93 can't unalias in a subshell. Since install.sh does a test
				# initialisation modernish in a subshell, we can't fail on 'unalias'.

# FTL_UNALIASA: Can't remove all aliases. (Tested earlier)
case ${_Msh_FTL_UNALIASA+s} in
( s )  _Msh_have FTL_UNALIASA "No support for 'unalias -a'.${ZSH_VERSION+ (zsh 5.0.8 fixes this)}" ;;
esac

# Make sure that we have a way to guarantee running a shell builtin.
# Note: we can only use 'special builtins' here or yash in posix mode will fail this test.
# See: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_14
# FTL_NOCOMMAND: Debian posh; zsh < 4.2
{	unset -f command
	_Msh_test=x
	command -v unset \
	&& command -V unset \
	&& command -p unset _Msh_test \
	&& case ${_Msh_test+s} in ( s ) false ;; esac
} >| /dev/null 2>&1 || _Msh_have FTL_NOCOMMAND "No or broken 'command' builtin."

# FTL_COMMAND2P: double parsing of grammar and/or parameter expansion
# when using 'command' with an external command.
# (AT&T ksh88; schilytools sh <= 2017-08-14)
unset -v _Msh_test
command /dev/null \${_Msh_test=x} 2>/dev/null
case ${_Msh_test+s} in
( s )	_Msh_have FTL_COMMAND2P "'command' builtin with external cmd doubly parses expansions." ;;
esac

# On some shells (e.g. mksh), the POSIX 'type' command is an alias. We just
# killed it, so restore it, to avoid it being either missing or run as an
# external command (where the results w.r.t. what is a builtin don't apply
# to the currrent shell).
# In all the shells I've tested except bash (which has 'type -t'), the
# 'type' output is exactly equivalent to 'command -V' (capital V). However,
# POSIX standardises 'command -V' in more detail than it does 'type', while
# every possible output of 'command -V' also matches the less-detailed
# definition of 'type'.
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/command.html
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/type.html
case " ${_Msh_cap} " in
( *\ FTL_NOALIAS\ * ) ;;	# skip: not applicable
( * )	command -V type >| /dev/null 2>&1 || alias type='command -V' ;;
esac

# FTL_DEVCLOBBR: Can't redirect output to devices if 'set -C' is active
# (a.k.a. 'set -o noclobber'). Workaround: use >| instead of >.  Found on:
# - NetBSD sh <= 8.0
# - bash 4.1 on Cygwin (for /dev/tty only; can only test this if we have a tty)
_Msh_test=$-
set -C
if PATH=$DEFPATH command test -c /dev/tty >|/dev/tty; then
	command : >/dev/tty
else
	command : >/dev/null
fi 2>|/dev/null || _Msh_have FTL_DEVCLOBBR "Can't redirect output to device if 'set -o noclobber'."
case ${_Msh_test} in
( *C* )	;;
( * )	set +C ;;
esac

# FTL_NOARITH, BUG_NOOCTAL
# Test for complete POSIX shell arithmetics support. Run test in a subshell
# because shells exit on 'syntax error', thwarting our error message.
# Test for arithmetic:
#	- additive assignment (+=)
#	- comparison (==, >)
#	- conditional expression (x?y:z)
#	- hexadecimal numbers (0x2A == 42)
#	- octal numbers (014 == 12, 015 == 13)
# (NetBSD /bin/sh, Slackware /bin/ash, original pdksh (no hex or octal)).
(	i=7
	j=0
	case $(( ((j+=6*i)==0x2A)>0 ? 014 : 015 )) in
	( 12 )	case $j in
		( 42 )	;;
		( * )	\exit 1 ;;
		esac ;;
	( 14 )	case $j in
		( 42 )	\exit 14 ;;
		( * )	\exit 1 ;;
		esac ;;
	( * )	\exit 1 ;;
	esac
) 2>| /dev/null \
|| case $? in
( 14 )	_Msh_have BUG_NOOCTAL ;;
( * )	_Msh_have FTL_NOARITH "Incomplete and/or broken POSIX shell arithmetics." ;;
esac

# FTL_ARITHPREC: on dash <= 0.5.5.1, binary operator parsing doesn't
# respect operator precedence correctly in the case where a lower-
# precedence operator is followed by a higher-precedence operator,
# and then by a lower-precedence operator. (dash-git commit 9655c1ac)
case $((37-16%7+9)) in
( 44 )	;;
( 26 )	_Msh_have FTL_ARITHPREC "Wrong operator precedence on shell arithmetics." ;;	# 37-16%7-9
( * )	_Msh_have FTL_ARITHPREN "Undiscivered bug with shell arithmetic calculation." ;;
esac

# ... fatal bugs with 'case' ...

# pdksh 5.2.14nb5 from NetBSD pkgsrc has a very obscure bug: it fails to
# match a list of characters from a variable in a bracket pattern, but only
# if the variable name is exactly 14 characters long! (It breaks
# shellquote() because $SHELLSAFECHARS, which it uses in a bracket
# pattern, is a 14 character variable name.)
_Msh_test_1234=x	# 14 character variable name
case x in
( [${_Msh_test_1234}] ) ;;
( * )	_Msh_have FTL_FOURTEEN "Problem with 14 characters long variable names." ;;
esac
unset -v _Msh_test_1234

# FTL_CASEQUOT: can't use quotes in 'case' matching patterns. (Debian posh)
case " some stuff here " in
( *' stuff '* ) ;;
( * )	_Msh_have FTL_CASEQUOT "Can't use quotes in 'case' matching patterns." ;;
esac

# FTL_BRACSQBR: the closing square bracket ']', even if escaped or passed
# from a quoted variable, causes a non-match in a glob bracket pattern, even
# if another character is matched. In other words, bracket patterns can never
# contain the closing square bracket as a character to match.
# Bug found on:
# - older FreeBSD /bin/sh
# - AT&T ksh93 "JM 93t+ 2010-03-05" and "JM 93t+ 2010-06-21"
_Msh_test='ab]cd'
case c in
( *["${_Msh_test}"]* )
	case e in
	( *[!"${_Msh_test}"]* ) ;;
	( * ) _Msh_have FTL_BRACSQBR "Negated bracket patterns can't contain a quoted closing square bracket." ;;
	esac ;;
( * )	_Msh_have FTL_BRACSQBR "Bracket patterns can't contain a quoted closing square bracket." ;;
esac

# FTL_BRACHYPH: a hyphen anywhere in a bracket pattern always produces a
# positive match. (AT&T ksh Version M 1993-12-28 p, at least on Mac OS X 10.4)
case e in
( [a-] | [a-d] | [-a] ) _Msh_have FTL_BRACHYPH "Hyphen produces false positive in bracket patterns." ;;
esac

# FTL_ORNOT: '!' does not invert the exit status of a 'case' after '||'
# (discovered in busybox ash 1.25.0git; no one runs old dev code, but it is
# trivial to test for this in case another shell ever has a bug with '!')
{ ! : || ! case x in x) ;; esac; } && _Msh_have FTL_ORNOT "'!' does not reliably invert exit status."

# FTL_GLOBHIBYT: glob patterns don't match high-byte characters (> 127).
# Found in bosh when compiled on Linux. Probably a bug in glibc.
# A variant was found on yash on Solaris under an ISO-8859-1 locale.
case XaYÃ¶b in
( X*Y* )	;;
( * | XaYÃ¶b )	_Msh_have FTL_GLOBHIBYT "Glob patterns don't match high-byte characters." ;;
esac

# FTL_CASEBKSL: Double-quoted patterns don't match unescaped backslashes. (found in Busybox ash 1.28.0)
case \\z in
( "\z" ) ;;
( * )	_Msh_have FTL_CASEBKSL "Double-quoted patterns with unescaped backslashes don't match." ;;
esac

# FTL_EMPTYBRE: empty bracket expressions eat subsequent shell grammar, producing unexpected results (in the
# test example below, a false positive match, because the two patterns are taken as one, with the "|" being
# taken as part of the bracket expression rather than shell grammar separating two bracket expressions).
_Msh_test=''
case abc in
( ["${_Msh_test}"] | [!a-z]* )
	_Msh_have FTL_EMPTYBRE \
	"Empty bracket expr eats shell grammar.${ZSH_VERSION+ (zsh 5.0.8 fixes this)}${YASH_VERSION+ (yash 2.15 fixes this)}" ;;
esac

# ... end of fatal bugs with 'case' ...

# FTL_PARONEARG: When IFS is empty on most versions of pdksh (i.e. field splitting is off),
# "$@" fails to generate separate words for each PP and joins the PPs together instead.
# BUG_PP_1ARG: Like FTL_PARONEARG, but for ${1+"$@"}.
IFS=''
_Msh_testFn() {
	_Msh_testFn2 "$@" || { _Msh_have FTL_PARONEARG \
	'"$@" becomes one single argument if field splitting is disabled.'	# pdksh, oksh, posh, mksh before R44
	return; }
	_Msh_testFn2 ${1+"$@"} || _Msh_have BUG_PP_1ARG				# bash 3.x and 4.{0..3}; old zsh 4.x
}
_Msh_testFn2() {
	case $# in
	( 1 )	return 1 ;;
	( 4 )	;;
	( * )	_Msh_have FTL_PARNEWBUG 'Undiscovered bug with "$@"! Please report.' "($#)" ;;
	esac
}
_Msh_testFn "   \on\e" "\tw'o" " \th\'re\e" " \\'fo\u\r "

# FTL_SUBSTIFS: parameter substitution changes all existing spaces in the
# variable to the first character in IFS. (zsh 4.1.1)
_Msh_test='1 2 3'
IFS='x '  # this zsh bug is only triggered if IFS has space as 2nd char
_Msh_test=${_Msh_test+$_Msh_test }4\ 5
IFS=' '
case ${_Msh_test} in
( '1 2 3 4 5' )	;;
( '1x2x3 4 5' )	_Msh_have FTL_SUBSTIFS "Parameter substitution changes spaces to IFS char." ;;
( '*' )		_Msh_have FTL_PSTNEWBUG "Undiscovered bug with parameter substitution! (${_Msh_test})" ;;
esac

# FTL_PSUB: parameter substitution fails to match certain
# patterns. (yash < 2.40)
#  *  The parameter expansion ${foo##bar*} was being treated like
#     ${foo##bar} where the asterisk should match up to the end of the
#     parameter value.
#  *  The parameter expansion ${foo%%*} was being expanded to ${foo}
#     where it should expand to an empty string.
_Msh_test='barbarfoo'
case ${_Msh_test##bar*}/${_Msh_test%%*} in
( / )	;;
( barfoo/barbarfoo )
	_Msh_have FTL_PSUB "Parameter substitution fails to match certain patterns.${YASH_VERSION+ (yash 2.40 fixes this)}" ;;
( * )	_Msh_have FTL_PSUBNEW "Undiscovered bug with parameter substitution! (${_Msh_test##bar*}/${_Msh_test%%*})" ;;
esac

# FTL_PSUB2: glob patterns in parameter substitutions (#, %, ##, %%) are wrongly
# subject to parsing under certain conditions: expansions, command substitution,
# backslash parsing. (bosh/schily sh <= 2017-11-21)
_Msh_test='a${_Msh_test2=BUG}'
unset -v _Msh_test2
_Msh_test=${_Msh_test%"${_Msh_test#a}"}   # "
case ${_Msh_test},${_Msh_test2-}, in	# FTL_PSUB4 compat: extra comma
( 'a,,' ) ;;
( 'a${_Msh_test2=BUG},BUG,' )
	_Msh_have FTL_PSUB2 "Parameter substitution: patterns wrongly subject to expansions." ;;
( * )	_Msh_have FTL_PSUB2NEW "Undiscovered bug with parameter substitution! (${_Msh_test},${_Msh_test2-})" ;;
esac

# FTL_PSUB3: glob patterns in parameter substitutions (#, %, ##, %%) cause
# quoted patterns to not match. (bosh/schily sh 2018-03-01)
_Msh_test=abcdefghij
_Msh_test2=efg
case ${_Msh_test#*"$_Msh_test2"} in
( hij ) ;;
( abcdefghij )
	_Msh_have FTL_PSUB3 "Parameter substitution: quoted patterns fail to match." ;;
( * )	_Msh_have FTL_PSUB3NEW "Undiscovered bug with parameter substitution! (${_Msh_test#*"$_Msh_test2"})" ;;
esac

# FTL_PSUB4: a parameter substitution of the form ${var-} or ${var:-},
# at the end of an argument, erases the entire argument. (mksh R50d)
_Msh_test=
case foo${_Msh_test:-} in
( '' )	_Msh_have FTL_PSUB4 "Parameters of form \${var-} or \${var:-} erase entire preceding word." ;;
esac

# FTL_PSUBPP: if a parameter substitution modifies one positional parameter with a
# pattern containing another positional parameter, the result is corrupted. (pdksh)
_Msh_testFn() {
	set ' foo -> bar' foo
	case ${1#" $2 -> "} in
	( bar ) ;;
	( * ) return 1 ;;
	esac
}
if ! _Msh_testFn; then
	_Msh_have FTL_PSUBPP "Parameter substitutions on positional parameters are corrupted."
fi

# FTL_HASHVAR: $#var means the length of $var - other shells and POSIX require braces, as in ${#var}. This
# causes interesting bugs when combining $#, being the number of positional parameters, with other strings.
_Msh_test=$$
case $#${_Msh_test},$(($#-1+1)) in
( "${#}${$},${#}" )
	;;
( "${#_Msh_test}{_Msh_test},${#-}2" | "${#_Msh_test}{_Msh_test},2" )
	# the second bug pattern applies if ${#-} is zero
	_Msh_have FTL_HASHVAR "Parsing of \$# is non-POSIX.${ZSH_VERSION+ (zsh 5.0.8 fixes this)}" ;;
( * )	_Msh_have FTL_HASHVARU "Undiscovered bug with parsing $# !" ;;
esac

# FTL_EVALRET: shell doesn't return from a function if the "return"
# is within an 'eval', but only from the 'eval'. (yash < 2.39)
# http://osdn.jp/ticket/browse.php?group_id=3863&tid=35232
# (In modernish 0.02dev this was a non-fatal BUG_EVALRET and the code
# included workarounds, but yash up to 2.39 turns out to have FTL_PSUB,
# so we can stop working around bugs from that version and before.)
_Msh_testFn() { true; eval "return $?"; false; }
if ! _Msh_testFn; then
	_Msh_have FTL_EVALRET "No return from function if 'return' within 'eval'.${YASH_VERSION+ (yash 2.39 fixes this)}"
fi

# FTL_EVALERR: 'eval' does not return an error exit status (> 0) on syntax
# error. This kills all feature testing based on shell grammar features,
# giving false positives on tests like HERESTR.t, causing subsequent breakage.
# (Found on busybox 1.26.0)
(eval '(') 2>/dev/null && _Msh_have FTL_EVALERR "No error exit status from 'eval' on syntax error."

# FTL_ROUNDMLN: AT&T ksh version "M 1993-12-28 s+" (pre-installed version
# on Mac OS X 10.7) has rounding errors in integer arithmetic when ordinary
# shell assignments or comparisons are used on numbers greater than one
# million; only pure shell arithmetic expressions work (up to 64 bits).
# FTL_ARITHASGN: Arithmetic assignment fails if the variable already
# contains a value that cannot be converted to arithmetic. (yash < 2.40)
case " ${_Msh_cap} " in
( *" FTL_NOARITH "* ) ;;  # Skip: not applicable.
( * )	unset -v _Msh_test2
	{ command -v typeset && typeset -i _Msh_test2; } >|/dev/null 2>&1  # suppress ksh93 rendering variable as float exponential
	_Msh_test2=$((1000005))
	_Msh_test=foo\\bar
	( : "$((_Msh_test = 1000005))" ) 2>|/dev/null && : "$((_Msh_test = 1000005))"
	case "${_Msh_test2},$((1000001)),$((1000005)),${_Msh_test}" in
	( 1000005,1000001,1000005,1000005 ) ;;
	( 1000005,1000001,1000005,foo\\bar )
		_Msh_have FTL_ARITHASGN "Arith assignment fails after string assignment. ${YASH_VERSION+(yash 2.40 fixes this)}" ;;
	( 1000010,1e+06,1*00001e+06,1000005 )
		_Msh_have FTL_ROUNDMLN 'Broken shell assignment/comparison: rounding errors after 1 million' ;;
	( * )	_Msh_have FTL_ROUNDNEW "Undiscovered bug in shell arith! (${_Msh_test2},$((1000001)),$((1000005)),${_Msh_test})" ;;
	esac
	unset -v _Msh_test2  # undo typeset -i
	;;
esac

# FTL_NOFNOVER: Can't override shell builtins with shell functions. (ksh88)
{ echo() { :; }; } 2>|/dev/null && unset -f echo || _Msh_have FTL_NOFNOVER "Can't override shell builtins with functions."

# FTL_NOPPID: no $PPID variable (parent's process ID). (NetBSD sh)
case ${PPID-} in
( '' | 0* | *[!0123456789]* )
	_Msh_have FTL_NOPPID 'No $PPID.' ;;
esac

# FTL_ASTERWRD: "$*" (ASTERisk) resolves to multiple WoRDs (i.e. acts
# like "$@") when IFS is empty. This is fatal for scripts using 'safe'.
# (Bug found in zsh 4.3.12 to 4.3.17)
IFS=''
_Msh_testFn2() {
	_Msh_test=$#
}
_Msh_testFn() {
	set -- one two three four
	_Msh_testFn2 "$*"
}
_Msh_testFn
case ${_Msh_test} in
( 1 )	;;
( * )	_Msh_have FTL_ASTERWRD 'Broken "$*", does not yield single word when IFS empty'
esac
IFS=' '

# FTL_SUBSHEXIT: Incorrect exit status within subshells.
# (bash 4.3 and 4.4 compiled without job control)
case " ${_Msh_cap} " in
( *\ FTL_NOCOMMAND\ * )
	;;	# skip: can't use "command"
( * )
	( command -p false && exit 13 || exit 37 )
	_Msh_test=$?	# BUG_CASESTAT compat
	case ${_Msh_test} in
	( 37 )	;;
	( * )	_Msh_have FTL_SUBSHEXIT "Exit status of commands in subshells is broken. (${_Msh_test})" ;;
	esac ;;
esac

# FTL_FNREDIR: I/O redirections on function definition commands are not
# remembered or honoured when the function is executed. (zsh < 5.0.7)
_Msh_testFn() {
	command : <&5
} 5</dev/null
_Msh_testFn 2>/dev/null 5<&- || _Msh_have FTL_FNREDIR "I/O redir on function defs ignored.${ZSH_VERSION+ (zsh 5.0.7 fixes this)}"

# FTL_ASGNBIERR: Variable assignments preceding regular builtin commands
# should not persist after the command exits, but with this bug they do if
# the command exits with an error. This may break various scripts in obscure
# ways and certainly destroys some modernish feature tests (particularly,
# 'PATH=temp_path builtin_with_error' causes the temporary $PATH to persist!)
# Bug found on AT&T ksh93 version "M 1993-12-28 r".
_Msh_test=ok
_Msh_test=bug command -@ 2>/dev/null	# invalid option triggers error
case ${_Msh_test} in
( bug )	_Msh_have FTL_ASGNBIERR 'Assignments preceding a regular builtin persist if it encounters an error.' ;;
( ok )	;;
( * )	_Msh_have FTL_ASGNBIERR 'Internal error.' ;;
esac

# FTL_UPP (Unset Positional Parameters): Cannot access "$@" or "$*" if set -u
# (-o nounset) is active and there are no positional parameters. If that
# option is set, NetBSD /bin/sh and older versions of ksh93 and pdksh error
# out on accessing "$@" and "$*" (the collective positional parameters), even
# if that access is implicit in a 'for' loop (as in 'for var do stuff; done').
# This is against the standard:
#     "-u: When the shell tries to expand an unset parameter OTHER THAN THE
#     '@' AND '*' SPECIAL PARAMETERS, it shall write a message to standard
#     error and shall not execute the command containing the expansion [...]".
# Reference:
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_25_03
# (under '-u').
if ! ( set -u --; set -- "$@"; _Msh_test=$*; for _Msh_test do :; done; ) 2>| /dev/null
then
	_Msh_have FTL_UPP '"$@"/"$*" error out if they are empty and "set -u" is active.'
fi

# FTL_UNSETFAIL: the 'unset' command sets a non-zero (fail) exit status if
# the variable to unset was either not set (some pdksh versions), or never
# set before (AT&T ksh 1993-12-28). This is contrary to POSIX, which says:
# "Unsetting a variable or function that was not previously set shall not be
# considered an error [...]". Reference:
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_29_03
# To detect this bug on AT&T ksh, use a variable that we're pretty sure was
# never set before in any program in the world, ever ('uuidgen' helped).
unset -v _Msh_FTL_UNSETFAIL_D7CDE27B_C03A_4B45_8050_30A9292BDE74 \
|| _Msh_have FTL_UNSETFAIL "'unset' returns error status on unsetting unset variables."

# FTL_EVALALIAS: aliases aren't expanded in 'eval'
case " ${_Msh_cap} " in
( *\ FTL_NOALIAS\ * ) ;;	# skip: not applicable
( * )	_Msh_testFn() { ! :; }
	alias _Msh_testFn=:
	eval _Msh_testFn || _Msh_have FTL_EVALALIAS "No alias expansion in 'eval'."
	unalias _Msh_testFn ;;
esac

# FTL_SQBKSL: dash 0.5.10, 0.5.10.1
case 'foo\
bar' in
( foo\\"
"bar )	;;
( foobar )
	_Msh_have FTL_SQBKSL "Backslashes are misparsed in single-quoted strings." ;;
( * )	_Msh_have FTL_SQBKSLN "Undiscovered bug with single-quoted strings!" ;;
esac

# --- Non-fatal bug tests ---

# BUG_MULTIBYTE: We're running on a locale with a variable-length character
# set (i.e. UTF-8) but the shell does not support multi-byte characters. For
# instance, ${#var} measures length in bytes, not characters. With
# fixed-length one-byte character sets, the bug is irrelevant so we don't
# set the identifier. Current shells with this bug include dash and most
# branches of pdksh.
# Note: Currently, BUG_MULTIBYTE is only detected if we're in a UTF-8 locale.
# (This is the only multibyte locale supported by current shells.)
# It should not be detected for single-byte locales as it's irrelevant there.
# Ref.: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_02
case ${LC_ALL:-${LC_CTYPE:-${LANG:-}}} in
( *.[Uu][Tt][Ff]8 | *.[Uu][Tt][Ff]-8 )
	_Msh_test='bÃ¨ta' # 4 char, 5 byte UTF-8 string 'beta' with accent grave on 'e'
	case ${#_Msh_test} in
	( 4 )	;;
	( 5 )	_Msh_have BUG_MULTIBYTE ;;
	( * )	_Msh_have FTL_UTFLENGTH "Fatal error in measuring UTF-8 string length. (${#_Msh_test})" ;;
	esac
	# FTL_UTFCASE: shell cannot relibaly compare UTF-8 characters.
	# (found on busybox with CONFIG_LOCALE_SUPPORT enabled)
	case "Ï" in
	( "Ï" )	;;
	( * )	_Msh_have FTL_UTFCASE "'case' cannot relibaly compare UTF-8 chars.
		(If this is busybox, recompile with CONFIG_LOCALE_SUPPORT off)" ;;
	esac ;;
esac

# QRK_IFSFINAL: in field splitting, a final non-whitespace IFS delimiter
# character is counted as an empty field (yash, zsh, pdksh)
# The POSIX standard is pretty ambiguous on this:
# https://osdn.jp/ticket/browse.php?group_id=3863&tid=35283#comment:3863:35283:1435293070
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_05
# http://www.mail-archive.com/bug-bash@gnu.org/msg05283.html
# It's a QRK (quirk), not a BUG, because it's not clear that the uncommon
# field splitting behaviour is a POSIX compliance bug, but it's certainly in
# the minority among shells.
#
# Also test for fatal fieldsplitting bugs in other shells. The ones
# involving backslashes would break shellquote() in particular. To make sure
# shellquote() works correctly, also include single quotes in the test.
IFS=': '
_Msh_test='  ::  \on\e :\tw'\''o \th\'\''re\e :\\'\''fo\u\r:   : :  '
_Msh_testFn() {
	IFS=' '	# avoid FTL_SUBSTIFS adding :s to _Msh_cap on old zsh
	case ${#},${1-U},${2-U},${3-U},${4-U},${5-U},${6-U},${7-U},${8-U},${9-U},${10-U},${11-U},${12-U}, in
	( '8,,,\on\e,\tw'\''o,\th\'\''re\e,\\'\''fo\u\r,,,U,U,U,U,' )
		# no quirks or bugs (bash, ash, dash, ksh93, mksh, ...)
		;;
	( '9,,,\on\e,\tw'\''o,\th\'\''re\e,\\'\''fo\u\r,,,,U,U,U,' )
		# zsh, yash
		_Msh_have QRK_IFSFINAL
		;;
	( '11,,,\on\e,,\tw'\''o,\th\'\''re\e,,\\'\''fo\u\r,,,,U,' )
		# pdksh
		_Msh_have QRK_IFSFINAL
		_Msh_have FTL_IFSWHSP "Field splitting: incorrect IFS whitespace removal."
		;;
	( '9,,,on\e,tw'\''o,th\'\''re\e,\'\''fo\u\r,,,,U,U,U,' )
		# yash 2.8 to 2.37
		_Msh_have QRK_IFSFINAL
		_Msh_have FTL_IFSBKSL "Field splitting eats initial backslashes.${YASH_VERSION+ (yash 2.38 fixes this)}"
		;;
	( '9,,,\on\e,\tw'\''o,\th\'\''re\e,\'\''fo\u\r,,,,U,U,U,' )
		# zsh up to 4.2.6
		_Msh_have QRK_IFSFINAL
		_Msh_have FTL_IFSEFODB "Field splitting eats first of double backslash.${ZSH_VERSION+ (zsh 4.2.7 fixes this)}"
		;;
	( '8,,\on\e,\tw'\''o,\th\'\''re\e,\\'\''fo\u\r,,,,U,U,U,U,' )
		# ksh93 Version M 1993-12-28 p
		# Bug with IFS whitespace: an initial empty whitespace-separated field
		# appears at the end of the expansion result instead of the start
		# if IFS contains both whitespace and non-whitespace characters.
		_Msh_have FTL_IFSWHSPE "Split: Initial empty field moved to end of expansion."
		;;
	( '7,::,\on\e,:\tw'\''o,\th\'\''re\e,:\\'\''fo\u\r:,:,:,U,U,U,U,U,' )
		# ksh93 with a DEBUG trap set
		_Msh_have FTL_IFSNONWH "Non-whitespace ignored in field splitting."
		;;
	( '1,  ::  \on\e :\tw'\''o \th\'\''re\e :\\'\''fo\u\r:   : :  ,U,U,U,U,U,U,U,U,U,U,U,' )
		_Msh_have FTL_NOFSPLIT "No field splitting. (Native zsh mode?)"
		;;
	( * )	_Msh_have FTL_IFSNWBUG "Undiscovered quirk or bug with field splitting! Please report. (${#},${1-U},${2-U},${3-U},${4-U},${5-U},${6-U},${7-U},${8-U},${9-U},${10-U},${11-U},${12-U},)"
		;;
	esac
}
_Msh_testFn ${_Msh_test}

# BUG_IFSISSET: From the AT&T ksh93 changelog:
# 13-06-20  A bug in which  ${IFS+abc} did not expand to abc when IFS is
#           unset has been fixed.
# This introduces a bug, it doesn't fix one. The parameter substitution
# ${var+x} is not supposed to expand to anything if 'var' is unset. IFS is not
# special in this regard, and ksh93 as of 2013-06-20 is unique in the POSIX
# world with this behaviour. Even its proprietary 'test -v' (to test if a
# variable is set) is affected. So on recent ksh93, the only way to test if
# IFS is set or not is by analysing the shell's field splitting behaviour.
unset -v IFS
case ${IFS+s} in
( '' )	;;
( s )	_Msh_have BUG_IFSISSET ;;
esac
IFS=' '

# --- Tests for optional, non-standard, but common features. ---

# Seed the $RANDOM pseudorandom number generator if we have it. In any case, set it
# to read-only to block unsetting/overwriting and using it as a regular variable.
# Modernish library functions depend on it either working properly or being absent.
case ${RANDOM+s},${RANDOM-} in
( s, | s,*[!0123456789]* )
	unset -v RANDOM ;;
( s,* )	# don't discard any seeding the shell may have done: xor our PID
	RANDOM=$((RANDOM ^ $$))
	case $RANDOM,$RANDOM,$RANDOM,$RANDOM in
	( "$RANDOM,$RANDOM,$RANDOM,$RANDOM" )
		unset -v RANDOM ;;
	( * )	_Msh_have RANDOM ;;
	esac ;;
esac
readonly RANDOM

# LOCALVARS: Function-local variables using the 'local' or 'typeset' special
# builtin or shell keyword on functions defined using POSIX syntax().
if _Msh_testFn() { local _Msh_test || return; _Msh_test=7; } \
&& _Msh_test=42 && _Msh_testFn && case ${_Msh_test} in (42);; (*) ! : ;; esac; then
	_Msh_have LOCALVARS
elif _Msh_testFn() { typeset _Msh_test || return; _Msh_test=7; } \
&& _Msh_test=42 && _Msh_testFn && case ${_Msh_test} in (42);; (*) ! : ;; esac; then
	# alias it on pdksh/mksh -- and yash, if not in posix mode
	alias local=typeset
	_Msh_have LOCALVARS
fi 2>|/dev/null

# KSH88FUNC: define ksh-style shell functions with the 'function' keyword,
# supporting local variables with the 'typeset' builtin. 
# KSH93FUNC: the same, but with static scoping for local variables.
# - NOTE: the superflous '()' must NOT be included; ksh93 doesn't accept it.
# - On AT&T ksh93, local variables are ONLY possible on functions defined
#   with the 'function' keyword and by using the 'typeset' builtin.
# This feature test was based on Q28 at http://kornshell.com/doc/faq.html
if command -v typeset && (eval 'function foo { :; }' && typeset foo=bar); then
	eval '
	function _Msh_testFn {
		_Msh_test2=${_Msh_test}
	}
	function _Msh_testFn2 {
		typeset _Msh_test=local || return
		_Msh_testFn
	}' &&
	_Msh_test=global &&
	_Msh_test2='' &&
	_Msh_testFn2 &&
	case ${_Msh_test2} in
	( global ) _Msh_have KSH93FUNC ;;
	( local )  _Msh_have KSH88FUNC ;;
	esac
fi >|/dev/null 2>&1

# --- Control character constants ---

# POSIX does not have a good way to refer to control characters in variable
# assignments or as parameters to arbitrary commands. Let's make this
# convenient using readonly variables (constants) in the CC[017][0-9A-F]
# and CC[a-z] namespaces (CC = control character).
# ATTENTION: LITERAL CONTROL CHARACTERS BELOW. Most editors handle this gracefully.
#
# We cannot have $CC00 because shell variables can't contain the 0 character.
		CC01=''	CC02=''	CC03=''	CC04=''	CC05=''	CC06=''	CC07=''
CC08=''	CC09='	'			CC0B=''	CC0C=''	CC0D=''	CC0E=''	CC0F=''
CC10=''	CC11=''	CC12=''	CC13=''	CC14=''	CC15=''	CC16=''	CC17=''
CC18=''	CC19=''	CC1A=''	CC1B=''	CC1C=''	CC1D=''	CC1E=''	CC1F=''
CC7F=''
# MAKE SURE THE FOLLOWING IS A LITERAL NEWLINE AND NOTHING ELSE.
CC0A='
'
# Make them constants.
readonly     CC01 CC02 CC03 CC04 CC05 CC06 CC07 \
	CC08 CC09 CC0A CC0B CC0C CC0D CC0E CC0F \
	CC10 CC11 CC12 CC13 CC14 CC15 CC16 CC17 \
	CC18 CC19 CC1A CC1B CC1C CC1D CC1E CC1F \
	CC7F || _Msh_have FTL_ROSERIES "'readonly' can't make a series of variables read-only."

# For convenience, provide some synonyms corresponding with 'printf' codes:
# e = escape; a = bell (alarm); b = backspace; f = form-feed; n = new-line;
# r = carriage return; t = tab; v = vertical tab
readonly "CCe=$CC1B" "CCa=$CC07" "CCb=$CC08" "CCf=$CC0C" "CCn=$CC0A" "CCr=$CC0D" "CCt=$CC09" "CCv=$CC0B" 2>/dev/null
# Check that this worked. If not, we have FTL_ROASSIGN.
case $CCe$CCa$CCb$CCf$CCn$CCr$CCt$CCv in
( "$CC1B$CC07$CC08$CC0C$CC0A$CC0D$CC09$CC0B" )
	# The following are handy to use in a glob pattern to check against control characters in a string:
	#	if match "$var" "*[$CONTROLCHARS]*"; then
	#		putln "\$var contains at least one control character"
	#	fi
	# ...or (using '!') for checking against characters *not* part of a particular set:
	#	case $var in
	#	( *[!"$ASCIICHARS"]* )	# (this breaks with FTL_BRACSQBR)
	#		putln "\$var contains at least one non-ASCII character" ;;
	#	esac
	# ...or for field splitting:
	#	IFS="$WHITESPACE,/"  # split fields at any whitespace, comma or slash, with space a primary separator
	# All the control characters:
	readonly "CONTROLCHARS=$CC01$CC02$CC03$CC04$CC05$CC06$CC07$CC08$CC09$CC0A$CC0B$CC0C$CC0D$CC0E$CC0F$CC10$CC11$CC12$CC13$CC14$CC15$CC16$CC17$CC18$CC19$CC1A$CC1B$CC1C$CC1D$CC1E$CC1F$CC7F"
	# All whitespace characters (starts with a space):
	readonly "WHITESPACE= $CCt$CCn$CCv$CCf$CCr"
	# The ASCII uppercase alphabet:
	readonly "ASCIIUPPER=ABCDEFGHIJKLMNOPQRSTUVWXYZ"
	# The ASCII lowercase alphabet:
	readonly "ASCIILOWER=abcdefghijklmnopqrstuvwxyz"
	# All the ASCII alphanumeric characters:
	readonly "ASCIIALNUM=0123456789${ASCIIUPPER}${ASCIILOWER}"
	# Safelist for shell-quoting, good for use in bracket patterns.
	readonly "SHELLSAFECHARS=${ASCIIALNUM}%+,./:=@_^!-"
	# The complete set of ASCII characters, good for use in bracket patterns.
	readonly "ASCIICHARS=${CONTROLCHARS} \"#\$&'()*;<>?[\\\\\\]\`{|}~${SHELLSAFECHARS}"
	;;
( * )	# FTL_ROASSIGN: unpatched pdksh
	_Msh_have FTL_ROASSIGN "'readonly' command doesn't support assignment."
	;;
esac

# FTL_CC7F: bash 2.05b and 3.0 have bugs with deleting $CC7F from expansions.
case ${#ASCIICHARS} in
( 129 )	;;
( * )	_Msh_have FTL_CC7F "Corrupted parameter expansion.${BASH_VERSION+ (bash 3.1 fixes this)}" ;;
esac

# FTL_CASECC: glob patterns as in 'case' cannot match an escaped literal ^A ($CC01) or DEL
# ($CC7F) control character. This kills modernish 'str match'. Found on: bash 2.05b, 3.0, 3.1
eval "case 'ab${CC01}c${CC7F}d' in
( \\a\\b\\${CC01}\\c\\${CC7F}\\d ) ;;
( * )	_Msh_have FTL_CASECC \"Globs don't match escaped ctrl chars.\${BASH_VERSION+ (bash 3.2 fixes this)}\"
esac"


# SIGPIPESTATUS
# According to POSIX, the numerical value of SIGPIPE is implementation-defined. In addition, different
# shells have different exit status offsets for signals: yash has signum+384, ksh93 has signum+256, the
# rest signum+128. So we have to kill a process with SIGPIPE to find out its exit status.
case $- in
( *m* )	# Slow but reliable method.
	SIGPIPESTATUS=$(exec "$MSH_SHELL" -c 'kill -s PIPE $$ || kill -PIPE $$; echo IGNORED')
	SIGPIPESTATUS=${SIGPIPESTATUS:-$?} ;;
( * )	# Fastest method because 'kill' will normally kill the background job before it even starts running.
	# Use it only with job control disabled to avoid job control clutter on the terminal.
	"$MSH_SHELL" -c ':' & kill -s PIPE "$!"
	wait "$!"	# acquire exit status from background job
	SIGPIPESTATUS=$?
	case $SIGPIPESTATUS in
	( ? | ?? | 1[01]? | 12[!9] )
		# - A race condition on some old shells may cause "wait $!" to yield status 0.
		# - An obscure intermittent bug on AT&T ksh93 may cause the exit status of "wait $!" to
		#   be 13 (the value of SIGPIPE without the mandatory offset), depending on the version.
		# - Maybe SIGPIPE is being ignored.
		# Fall back to the simple method for these cases, or any others where $? <= 128.
		SIGPIPESTATUS=$(exec "$MSH_SHELL" -c 'kill -s PIPE $$ || kill -PIPE $$; echo IGNORED')
		SIGPIPESTATUS=${SIGPIPESTATUS:-$?} ;;
	esac ;;
esac 2>/dev/null
case $SIGPIPESTATUS in
( IGNORED )
	_Msh_have WRN_NOSIGPIPE
	SIGPIPESTATUS=99999 ;;
( *[!0123456789]* | ? | ?? | 1[01]? | 12[!9] )
	_Msh_have FTL_SIGPIPEST "Can't determine SIGPIPESTATUS (bad value: $SIGPIPESTATUS)" ;;
esac
readonly SIGPIPESTATUS

# --- End of builtin tests ---
case ${_Msh_ftlcount} in
( 0 )	;;
( 1 )	_Msh_initExit "1 fatal shell bug found. This shell can't run modernish." ;;
( * )	_Msh_initExit "${_Msh_ftlcount} fatal shell bugs found. This shell can't run modernish." ;;
esac

# -------------

# Internal functions. Subject to change without notice.

_Msh_dieArgs() {
	die "$1: incorrect number of arguments (was $2, must be $3)"
}

# preliminary isset
isset() {
	eval "case \${$1+s} in ( '' ) return 1 ;; esac"
}

# -------------

# more readable synonym for '!'
alias not='! '		# note: final space = continue to expand aliases

# test preceding command's success with 'if so;' or 'if not so;'
alias so='{ let "$?==0"; }'	# we'll add 'let' to shells without it

# more readable indefinite loops
alias forever='while :;'

# die: Emergency program halt for fatal errors.
# On non-interactive shells, terminate the entire program, including subshells.
# On interactive shells, we can't exit, so attempt to interrupt compound command
# execution, or if that fails, merely return. Hence the need for "|| return".
# Usage: die [ <message> ] || return
unset -v _Msh_die_isrunning
case $- in
( *i* )
	# On an interactive shell, attempt to interrupt command execution (loops, compounds) and return
	# straight to the prompt, by sending SIGINT to the main shell, which is equivalent to pressing
	# Ctrl+C. Note that some shells allow SIGINT to be ignored (using the 'trap' command) even on
	# interactive shells. Since interactive die() may fail for that reason, we still need
	# '|| return' after every 'die' invocation.
	die() {
		case $# in
		( 0 )	;;
		( * )	put "${ME##*/}: ${@}${CCn}" >/dev/tty
			if ! is onterminal 2; then
				put "${ME##*/}: ${@}${CCn}" >&2
			fi ;;
		esac
		if insubshell; then
			# Interrupt main shell, then exit subshell.
			PATH=$DEFPATH command kill -s INT "$$"
			command exit 128
		else
			PATH=$DEFPATH command kill -s INT "$$"
			return 128
		fi
	}
	;;
( * )
	# Non-interactive: execute DIE traps if set (using var/stack/trap), then kill the program:
	# send SIGKILL to main process plus all its subprocesses (incl. subshells). This should
	# allow terminating a program even from within a subshell.
	#
	# Note that the process group (PID 0) may include not just subprocesses but parent
	# processes as well, e.g. a program that launched this one. We want to kill only
	# subprocesses. So instead of using 'kill -s KILL 0', use 'ps' and 'awk' to
	# recursively find only the subprocesses of $$, excluding DIE trap bg jobs.
	#
	# Determine a couple of things at init time to increase die()'s efficiency:
	# - 'ps' flags that show at least the PPID and PID columns (position/order irrelevant).
	case $(LC_ALL=C PATH=$DEFPATH exec ps -oppid,pid 2>/dev/null) in
	( *PPID*\ PID${CCn}*[0123456789]*\ *[0123456789]* )
		unset -v _Msh_psBroken ;;	# POSIX '-o ppid,pid' (efficient)
	( * )	_Msh_psBroken='-l' ;;		# Cygwin, legacy unix
	esac
	readonly _Msh_psBroken
	die() {
		# Save current exit status for DIE traps.
		_Msh_E=$?
		# Try to prevent loops.
		case ${_Msh_die_isrunning+s} in
		( s )	_Msh_doExit 128 "$@" ;;
		esac
		_Msh_die_isrunning=y
		alias die='_Msh_doExit 128'
		# The program is in an inconsistent/undefined state. For all we know it could be about to
		# delete all your data. Time is of the essence, so execute any and all DIE traps simultaneously.
		# (These DIE traps can be set or pushed if the var/stack/traps module is loaded.)
		# Also print the error message in the background in case output blocks due to redirection.
		# Save the main background job's PID in order to exclude it (and its subprocesses) from being killed,
		# Background jobs are </dev/null by default, which is unwanted for traps, so redirect stdin to a copy of itself.
		# (Preserving stdin allows 'stty' to restore terminal state from a trap.)
		{ command : 9<&0; } 2>/dev/null || exec </dev/null  # make sure stdin is open for copying
		{ {
			case ${_Msh__V_Msh_trapDIE__SP+s} in
			( s )	while let "(_Msh__V_Msh_trapDIE__SP-=1) >= 0"; do
					_Msh_doOneStackTrap DIE "${_Msh__V_Msh_trapDIE__SP}" "${_Msh_E}" 0<&8 &
				done ;;
			esac
			case ${_Msh_POSIXtrapDIE+p} in
			( p )	eval "setstatus ${_Msh_E}; ${_Msh_POSIXtrapDIE}" 0<&8 & ;;
			esac
			put "${ME##*/} died${1+: }$@$CCn" >/dev/tty	#\
			if ! is onterminal 2; then			# > BUG_PP_1ARG compat: use ${1+: }$@, not ${1+: $@}
				put "${ME##*/} died${1+: }$@$CCn" >&2	#/
			fi
		} & } 8<&0
		_Msh_tPID=$!
		# No need to save any settings now...
		export "PATH=$DEFPATH" LC_ALL=C
		set -o noglob
		IFS=$CCn
		unset -f ps awk	# QRK_EXECFNBI compat
		# Issue SIGKILL, which cannot be ignored and won't execute any other traps.
		# Recursively get all this shell's subprocesses with a little help from awk.
		# The awk program's algorithm is inspired by http://superuser.com/a/784102
		if insubshell -p; then
			# We can't exit the main shell from a subshell, so kill both the main shell and its subproccesses.
			#	[ If the main shell no longer exists, we're in a background subshell spawned by the defunct
			#	main shell. The awk program deals specially with this case. We might be in a subshell of (a
			#	subshell of ...) a background subshell, so move up into the process hierarchy until we find the
			#	orphaned (grand)parent, then kill it and all its subprocesses. That's the best we can do.
			#	There is no hope of catching any lateral background subshells spawned by the defunct main
			#	shell, as their association with our process hierarchy has been severed. ]
			command kill -s KILL $(exec ps ${_Msh_psBroken:--oppid,pid} | exec awk "
				NR==1 { for (i=1; i<=NF; i++) if (\$i==\"PPID\") pp=i; else if (\$i==\"PID\") p=i }
				NR>1 { subplist[\$pp]=(subplist[\$pp])(\" \")(\$p); parent[\$p]=\$pp }
				END {
					if (parent[$$]==\"\") getsubpids(bgmain($REPLY)); else getsubpids($$)
					print $REPLY	# kill self last
				}
				function bgmain(pid) {
					while (parent[parent[pid]]!=\"\" && parent[parent[pid]]!=parent[pid])
						pid=parent[pid]
					return pid
				}
				function getsubpids(pid,   numsubs, i, subpid) {
					if (pid!=$REPLY) print pid
					numsubs=split(subplist[pid], subpid, \" \")
					for (i=1; i<=numsubs; i++)
						if (subpid[i]!=${_Msh_tPID})
							getsubpids(subpid[i])
				}") 2>/dev/null
		else
			# Kill any subprocesses, then exit the main shell normally.
			command kill -s KILL $(exec ps ${_Msh_psBroken:--oppid,pid} | exec awk "
				NR==1 { for (i=1; i<=NF; i++) if (\$i==\"PPID\") pp=i; else if (\$i==\"PID\") p=i }
				NR>1 { subplist[\$pp]=(subplist[\$pp])(\" \")(\$p) }
				END { getsubpids($$) }
				function getsubpids(pid,   numsubs, i, subpid) {
					numsubs=split(subplist[pid], subpid, \" \")
					for (i=1; i<=numsubs; i++)
						if (subpid[i]!=${_Msh_tPID})
							{ print subpid[i]; getsubpids(subpid[i]) }
				}") 2>/dev/null
		fi
		command trap - 0  # clear EXIT trap (BUG_TRAPEXIT compat); only DIE traps are executed upon die()
		command exit 128
	}
	;;
esac

# Extended 'exit'. Usage: exit [ -u ] [ <status> [ <message> ] ]
# The <status> is a shell arithmetic expression.
alias exit=_Msh_doExit
unset -v _Msh_exit_inUsage
_Msh_doExit() {
	_Msh_exit_status=$?
	unset -v _Msh_exit_u
	while case ${1-} in ( -- ) shift; break ;; ( -* ) ;; ( * ) break ;; esac; do
		case $1 in
		( -u )	_Msh_exit_u= ;;
		( -* )	die "exit: invalid option: $1" || command exit ;;
		esac
		shift
	done
	let $# && _Msh_exit_status=$(( ($1) & 255 )) && shift
	let _Msh_exit_status 1>&2 && exec 1>&2
	let $# && put "${ME##*/}: ${@}${CCn}"
	isset _Msh_exit_u && ! isset _Msh_exit_inUsage && isset -f showusage && (_Msh_exit_inUsage= ; showusage)
	command exit "${_Msh_exit_status}"
}

# Manually set exit status ("$?") to the desired value. The canonical method
# is '(exit $status)' but that forks a subshell. Using a function is much
# faster. Don't do validation except for non-negative decimal integer, as
# many shells internally support exit statuses much greater than 255.
setstatus() {
	case ${#} in
	( 1 )	_Msh_sS_E=$(($1))
		case ${_Msh_sS_E} in
		( -* )	die "setstatus: negative exit status not supported" || return ;;
		( * )	eval "unset -v _Msh_sS_E; return ${_Msh_sS_E}" ;;
		esac ;;
	( * )	_Msh_dieArgs setstatus "$#" 1 || return ;;
	esac
}

# Use a modernish module.
# If the module is already loaded, does nothing and exits successfully
# (status 0), preventing dependency loops. The space-separated global
# internal variable _Msh_using keeps track of the modules in use.
# Option -q: query if the module is already loaded.
_Msh_using=''
use() {
	unset -v _Msh_use_q
	while	case ${1-} in
		( -- )		shift; break ;;
		( -q )		_Msh_use_q= ;;
		( -* )		die "use: unknown option: $1" || return ;;
		( * )		break ;;
		esac
	do
		shift
	done
	case ${_Msh_use_q+s} in
	( s )	let "$# == 1" || _Msh_dieArgs 'use -q' "$#" 1 || return ;;
	( * )	let "$#" || _Msh_dieArgs use "$#" 'at least 1' || return ;;
	esac
	! str match "${1:-\$}" "*[!$SHELLSAFECHARS]*" || die "use: invalid module name: $1" || return
	str in " ${_Msh_using} " " $1 " && unset -v _Msh_use_q && return 0
	isset _Msh_use_q && unset -v _Msh_use_q && return 1
	is -L reg "$MSH_PREFIX/libexec/modernish/$1.mm" || die "use: module $1 not found" || return

	push --key=_Msh_use -o allexport
	set +o allexport
	_Msh_doUse "$@"
	_Msh_E=$?
	pop --key=_Msh_use -o allexport
	case ${_Msh_E} in
	( 0 )	unset -v _Msh_e
		isset -i && putln "Using $1"
		_Msh_using=${_Msh_using}${_Msh_using:+ }$1 ;;
	( * )	die "use: initialisation of module $1 failed with status ${_Msh_E}" ;;
	esac
} >&2
# Wrapping the dot command in its own function works around bugs or quirks
# with 'return' on a couple of shells (yash < 2.44, older FreeBSD sh).
_Msh_doUse() {
	command . "$MSH_PREFIX/libexec/modernish/$1.mm"
}

# -------------

# **** thisshellhas() ****
# Test if all of the given words are shell keywords, regular or special
# built in commands, shell options, or (for words that are in all caps)
# optional capabilities or bugs that modernish found in the current shell.
#
# Usage: thisshellhas <item> [ <item> ... ]
#        thisshellhas [ --cache | --show ]
#
# If <item> contains only uppercase letter, digits or '_', return the result
# of the associated modernish feature, quirk or bug test.
# If <item> is an all-lowercase word, check if it's a shell reserved word or
# built-in command on the current shell.
# If <item> starts with --rw= or --kw=, check if it's a shell reserved word.
# If <item> starts with --bi=, check if it's a shell built-in command.
# If <item> is '-o' followed by a separate word, check if this shell has a
# long-form shell option by that name.
# If <item> is any other letter or digit preceded by a single '-', check if
# this shell has a short-form shell option by that character.
# --cache: run all external bug/quirk/feature tests and cache the results
# --show: like --cache, but also output all the IDs of positive results, one per line
#
# Feature/quirk/bug tests and shell option checks are cached in a variable
# so repeated checks are not inefficient.

# ** First, some internal functions to support thisshellhas():

# Preliminary function to source a bug/capability test (this will be used
# during initialisation before we have is(), so must use [ for now).
_Msh_doCapTest() {
	unset -v _Msh_test						# guarantee unset variable for testing purposes
	set -- "$MSH_PREFIX/libexec/modernish/cap/$1.t"			# this can be used by test scripts as well
	PATH=$DEFPATH command test -f "$1"
	case $? in
	( 0 )	. "$1" 1>&2 ;;
	( 1 )	return 127 ;;
	( * )	die "thisshellhas: doCapTest: 'test' failed" || return ;;
	esac
}
# Pre-cache the results of all the external capability/bug tests.
_Msh_cacheCap() {
	case ${_Msh_cap} in
	( '#ALLCACHED '* )
		if str id "${1-}" '--show'; then
			push IFS -f
			IFS=' '; set -f
			putln ${_Msh_cap#?ALLCACHED}
			pop IFS -f
		fi
		return ;;	# already done
	esac
	push IFS -f _Msh_c _Msh_newCap
	# do any external tests that haven't already been done
	IFS=''; set +f
	for _Msh_c in "$MSH_PREFIX"/libexec/modernish/cap/*.t; do
		_Msh_c=${_Msh_c##*/}
		_Msh_c=${_Msh_c%.t}
		case " ${_Msh_cap} " in
		( *" ${_Msh_c} "* | *" !${_Msh_c} "* ) continue ;;
		esac
		thisshellhas "${_Msh_c}"
	done
	# eliminate negative test results; they are redundant with #ALLCACHED tag
	_Msh_newCap=''
	IFS=' '; set -f
	for _Msh_c in ${_Msh_cap}; do
		case ${_Msh_c} in
		( !* ) continue ;;
		esac
		_Msh_newCap=${_Msh_newCap:+${_Msh_newCap} }${_Msh_c}
	done
	str id "${1-}" '--show' && putln ${_Msh_newCap}
	_Msh_cap="#ALLCACHED ${_Msh_newCap}"
	pop IFS -f _Msh_c _Msh_newCap
}

# ** Shell-specific code for thisshellhas():

# POSIX does not allow for a reliable way to find out what is a shell
# keyword or built in command, but it's essential for feature testing, so
# we have to make do with various shell-specific versions.

if isset BASH_VERSION && builtin shopt -s lastpipe 2>/dev/null
then
	# The LEPIPEMAIN capability (as of bash 4.2) needs to be tested for as a special
	# case, because bash only has this capability if 'shopt -s lastpipe' is active
	# *and* 'set -m' (job control) is *not* active, and either of those options may
	# be set or unset during the course of a program.
	_Msh_tSH_bashLEPIPEMAIN='case $1 in
			( LEPIPEMAIN )
				case $- in ( *m* ) return 1 ;; esac
				builtin shopt -p lastpipe >/dev/null || return 1 ;;
			esac'
else
	_Msh_tSH_bashLEPIPEMAIN=''
fi

if isset BASH_VERSION && builtin compgen -k
then
	# Version for bash (but not bash compiled with 'minimal configuration'). The
	# 'compgen' builtin easily lists all keywords (-k) and special/regular builtins
	# (-b). Store them in cache variables so that subsequent invocations of
	# thisshellhas() don't require forking command substitution subshells.
	readonly "_Msh_biCache=$(builtin compgen -b)" "_Msh_kwCache=$(builtin compgen -k)"
	_Msh_tSH_testBI='case $CCn${_Msh_biCache}$CCn in
			( *"$CCn${1#--bi=}$CCn"* ) ;;
			( * )	return 1 ;;
			esac'
	_Msh_tSH_testKW='case $CCn${_Msh_kwCache}$CCn in
			( *"$CCn${1#--[rk]w=}$CCn"* ) ;;
			( * )	return 1 ;;
			esac'
elif isset ZSH_VERSION && builtin enable -r
then
	# Version for zsh, using the same strategy as bash with compgen. 'enable -r' prints all
	# keywords (reserved words), just 'enable' prints all special and regular builtins.
	readonly "_Msh_biCache=$(builtin enable)" "_Msh_kwCache=$(builtin enable -r)"
	_Msh_tSH_testBI='case $CCn${_Msh_biCache}$CCn in
			( *"$CCn${1#--bi=}$CCn"* ) ;;
			( * )	return 1 ;;
			esac 2>/dev/null'	# suppress huge trace if set -x
	_Msh_tSH_testKW='case $CCn${_Msh_kwCache}$CCn in
			( *"$CCn${1#--[rk]w=}$CCn"* ) ;;
			( * )	return 1 ;;
			esac 2>/dev/null'	# suppress huge trace if set -x
elif isset YASH_VERSION && {
	PATH=$DEFPATH command test -o posix
	case $? in
	( 0 )	set +o posix; command -vkb if && set -o posix || ! set -o posix ;;
	( 1 )	command -vkb if ;;
	( * )	false ;;
	esac
}; then
	# Version for yash. 'command -v --keyword' (-vk) and 'command -v --builtin-command'
	# (-vb) do just what we want, but only if posix mode is off.
	_Msh_tSH_testBI='if PATH=$DEFPATH command test -o posix; then
				set +o posix
				command -vb -- "${1#--bi=}" || { set -o posix; return 1; }
				set -o posix
				# yash in POSIX mode checks builtins against $PATH, so recheck
				command -v "${1#--bi=}" || return 1
			else
				command -vb -- "${1#--bi=}" || return 1
			fi >/dev/null'
	_Msh_tSH_testKW='if PATH=$DEFPATH command test -o posix; then
				set +o posix
				command -vk -- "${1#--[rk]w=}" || { set -o posix; return 1; }
				set -o posix
			else
				command -vk -- "${1#--[rk]w=}" || return 1
			fi >/dev/null'
elif case " ${_Msh_cap} " in
     ( *' KSH93FUNC '* ) ;;
     ( * ) false ;;
     esac \
&& ( eval '[[ -n ${.sh.version+s} ]]' )
then
	# Version for ksh93.
	# The 'builtin' command lists all the builtins so we can cache them
	# (which is nice, because BUG_FNSUBSH on ksh93 kills the default method).
	# Some builtins have paths starting with path names and are only used
	# if the (not necessarily existent!) directory is in $PATH.
	# There is no way to list shell keywords, so use the default technique for those.
	readonly "_Msh_biCache=$(builtin)"
	_Msh_kwCache=
	_Msh_kwOutput=$(command -V 'while')
	readonly "_Msh_kwOutput=${_Msh_kwOutput#*while}"	# remove the keyword itself
	_Msh_tSH_testBI='case $CCn${_Msh_biCache}$CCn in
			( *"$CCn${1#--bi=}$CCn"* ) ;;
			( *"/${1#--bi=}$CCn"* )
				# Found builtin with path name. Isolate the "directory" and check $PATH.
				_Msh_tSH_D=${_Msh_biCache}${CCn}
				_Msh_tSH_D=${_Msh_tSH_D%%/${1#--bi=}${CCn}*}
				_Msh_tSH_D=${_Msh_tSH_D##*${CCn}}
				case :$PATH: in
				( *":${_Msh_tSH_D}:"* | *":${_Msh_tSH_D}/:"* )
					unset -v _Msh_tSH_D ;;
				( * )	unset -v _Msh_tSH_D; return 1 ;;
				esac ;;
			( * )	return 1 ;;
			esac'
	_Msh_tSH_testKW='case "${_Msh_kwCache} " in
			( *" ${1#--[rk]w=} "* ) ;;
			( *" !${1#--[rk]w=} "* ) return 1 ;;
			( * )	case $(command -V "${1#--[rk]w=}" 2>/dev/null) in
				( *"${_Msh_kwOutput}" )
					_Msh_kwCache="${_Msh_kwCache} ${1#--[rk]w=}" ;;
				( * )	_Msh_kwCache="${_Msh_kwCache} !${1#--[rk]w=}"
					return 1 ;;
				esac
			esac'
else
	# Generic/default version. As far as I know, this version works on all other shells;
	# at least dash, Busybox ash, FreeBSD /bin/sh, {pd,m}ksh.
	_Msh_biCache=
	_Msh_kwCache=
	# Distinguish a keyword from a builtin by checking against 'command -V' output of a POSIX keyword.
	_Msh_kwOutput=$(command -V 'while')
	readonly "_Msh_kwOutput=${_Msh_kwOutput#*while}"	# remove the keyword itself
	_Msh_tSH_testBI='thisshellhas "--rw=${1#--bi=}" && return 1
			case "${_Msh_biCache} " in
			( *" ${1#--bi=} "* )	;;
			( *" !${1#--bi=} "* )	return 1 ;;
			( * )	_Msh_biCache=${_Msh_biCache}\ $(
					unalias -- "${1#--bi=}" 2>/dev/null
					unset -f -- "${1#--bi=}" 2>/dev/null
					PATH=/dev/null
					command -v -- "${1#--bi=}") \
				|| {
					_Msh_biCache=${_Msh_biCache}!${1#--bi=}
					return 1
				} ;;
			esac'
	_Msh_tSH_testKW='case "${_Msh_kwCache} " in
			( *" ${1#--[rk]w=} "* )	;;
			( *" !${1#--[rk]w=} "* ) return 1 ;;
			( * )	case $(command -V "${1#--[rk]w=}" 2>/dev/null) in
				( *"${_Msh_kwOutput}" )
					_Msh_kwCache="${_Msh_kwCache} ${1#--[rk]w=}" ;;
				( * )	_Msh_kwCache="${_Msh_kwCache} !${1#--[rk]w=}"
					return 1 ;;
				esac
			esac'
fi >/dev/null 2>&1

# ** Main function. Insert the above-determined shell-specific code into it.

_Msh_optCache=
eval 'thisshellhas() {
	case ${#},${-} in
	( 0,* )	_Msh_dieArgs thisshellhas "$#" "at least 1" || return ;;
	( *a* )	set +a; thisshellhas "$@"; eval "set -a; return $?" ;;
	esac
	while :; do
		case $1 in
		( --cache )
			_Msh_cacheCap
			;;
		( --show )
			_Msh_cacheCap --show
			;;
		( "" | --bi= | --[rk]w= | --bi=*/* | --[rk]w=*/* \
		| --bi=*[!\[\]\!{}"$SHELLSAFECHARS"]* \
		| --[rk]w=*[!\[\]\!{}"$SHELLSAFECHARS"]* \
		| --sig=*[!"$SHELLSAFECHARS"]* )
			return 2  # invalid identifier
			;;
		( --bi=* )
			'"${_Msh_tSH_testBI}"'
			;;
		( --[rk]w=* )
			'"${_Msh_tSH_testKW}"'
			;;
		( --sig=* )
			use -q var/stack/trap || die "thisshellhas: --sig: requires var/stack/trap" || return
			if _Msh_arg2sig "${1#--sig=}" -nv; then
				REPLY=${_Msh_sig}
				unset -v _Msh_sig
			else
				unset -v _Msh_sig REPLY
				return 1
			fi ;;
		( --* )	die "thisshellhas: invalid option: ${1%%=*}" || return
			;;
		( -o )	case ${2-} in
			( allexport | errexit | ignoreeof | noclobber \
			| noglob | noexec | nounset | verbose | xtrace )
				;;
			( "" | *[!"$ASCIIALNUM"_-]* | -* )
				return 2 ;;
			( * )	case " ${_Msh_optCache} " in
				( *" $2 "* )	;;
				( *" !$2 "* )	return 1 ;;
				( * )	if (set +o "$2") 2>/dev/null; then
						_Msh_optCache=${_Msh_optCache:+${_Msh_optCache} }$2
					else
						_Msh_optCache=${_Msh_optCache:+${_Msh_optCache} }!$2
						return 1
					fi ;;
				esac ;;
			esac
			shift ;;
		( -[aCefmnuvx] )
			;;
		( -["$ASCIIALNUM"] )
			case " ${_Msh_optCache} " in
			( *" $1 "* )	;;
			( *" !$1 "* )	return 1 ;;
			( * )	if isset "$1" || (set "+${1#-}") 2>/dev/null; then
					_Msh_optCache=${_Msh_optCache:+${_Msh_optCache} }$1
				else
					_Msh_optCache=${_Msh_optCache:+${_Msh_optCache} }!$1
					return 1
				fi ;;
			esac ;;
		( -* )	return 2 ;;
		( *[!ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_]* )
			thisshellhas "--bi=$1" || thisshellhas "--rw=$1" || return
			;;
		( * )	'"${_Msh_tSH_bashLEPIPEMAIN}"'
			case " ${_Msh_cap} " in
			( *" $1 "* )	;;
			( *" !$1 "* | *" #ALLCACHED "* ) return 1 ;;
			( * )	_Msh_doCapTest "$1"
				case $? in
				( 0 )	_Msh_cap=${_Msh_cap:+${_Msh_cap} }$1
					unset -v _Msh_test ;;
				( 1 | 127 )	# 127 = *.t file not found
					_Msh_cap=${_Msh_cap:+${_Msh_cap} }!$1
					unset -v _Msh_test
					return 1 ;;
				( * )	die "thisshellhas(): failure while testing for $1" || return ;;
				esac ;;
			esac
			;;
		esac
		shift
		case $# in
		( 0 )	break ;;
		esac
	done
}'"${CCn}" || _Msh_initExit "thisshellhas() definition: 'eval' failed"
unset -v _Msh_tSH_testBI _Msh_tSH_testKW _Msh_tSH_bashLEPIPEMAIN

# -------------

# insubshell: Check if we're currently running in a subshell.
# Usage:	insubshell [ -p | -u ]
# Returns with status 0 if we're in a subshell, 1 if not.
# If -p is given, leaves the PID of the current (sub)shell in $REPLY.
# If -u is given, leaves a shell-specific identifier of the current (sub)shell in $REPLY. This is *only*
# useful for determining if you've entered a subshell relative to a previously stored identifier. Note
# that using the PID is not portable for that purpose as ksh93 uses non-forking subshells.
#
# Generic, slow version. We must exec a shell to get it to report our PID back to us.
# If modernish was installed properly, $MSH_SHELL is a known-good shell with $PPID.
_Msh_inSbSh_generic_part1='_Msh_inSbSh_P=$(exec "$MSH_SHELL" -c "set -o nounset && echo \$PPID" 2>/dev/null) \
	&& case ${_Msh_inSbSh_P} in ("" | *[!0123456789]*) ! : ;; esac \
	|| _Msh_inSbSh_P=$(PATH=$DEFPATH exec /bin/sh -c '\''ppid=`ps -o ppid= -p $$` && echo $ppid'\'')
	case ${1-},${_Msh_inSbSh_P} in
	( *, | *,*[!0123456789]* )
		putln "${ME##*/}: insubshell: internal error: cannot determine parent PID" 1>&2
		isset _Msh_die_isrunning && return 0 || die ;;'
_Msh_inSbSh_generic_part2='
	(,$$)	unset -v _Msh_inSbSh_P; return 1 ;;
	(*,$$)	REPLY=$$; unset -v _Msh_inSbSh_P; return 1 ;;
	(,*)	unset -v _Msh_inSbSh_P; return 0 ;;
	(*,*)	REPLY=${_Msh_inSbSh_P}; unset -v _Msh_inSbSh_P; return 0 ;;
	esac'
# Try to determine an efficient shell-specific version.
if isset BASHPID &&
	_Msh_test=$BASHPID &&
	case $(command trap 'command -p echo "$((BASHPID != _Msh_test))"' EXIT;
		command -p echo "$((BASHPID != _Msh_test))") in
	("1${CCn}1")	;;
	( * )		unset -v BASHPID || _Msh_initExit "can't unset non-working BASHPID!"
			! : ;;
	esac
then	# bash 4 and mksh
	# note inverted comparison: true = 1 = return false
	_Msh_inSbSh_method='case $# in ( 1 ) return "$(((REPLY = BASHPID) == $$))" ;; esac
		return "$((BASHPID == $$))"'
elif isset ZSH_VERSION && isset ZSH_SUBSHELL &&
	_Msh_test=$ZSH_SUBSHELL &&
	case $(command trap 'command -p echo "$((ZSH_SUBSHELL != _Msh_test))"' EXIT;
		command -p echo "$((ZSH_SUBSHELL != _Msh_test))") in
	("1${CCn}1")	;;
	( * )		unset -v ZSH_SUBSHELL || _Msh_initExit "can't unset non-working ZSH_SUBSHELL!"
			! : ;;
	esac
then	# zsh: $ZSH_SUBSHELL can tell us whether we're in a subshell, but not its PID, so fall back to generic for that.
	_Msh_inSbSh_method='case ${1-},${ZSH_SUBSHELL} in
		(,0)	return 1 ;;
		(,*)	return 0 ;;
		(-p,0)	REPLY=$$; return 1 ;;
		(-u,*)	return "$((!(REPLY = ZSH_SUBSHELL)))" ;;
		esac
		'"${_Msh_inSbSh_generic_part1}"'
		esac
		REPLY=${_Msh_inSbSh_P}; unset -v _Msh_inSbSh_P'
elif case ${KSH_VERSION-} in ( Version* ) ;; ( * ) ! : ;; esac; then
	# AT&T ksh93. It usually does non-background subshells without forking a new process. However, such a
	# non-forked subshell might fork mid-execution at any time, e.g. when executing 'ulimit' or performing a
	# redirection within a command substitution. As the PID changes *and* ${.sh.subshell} is reset to 0 when
	# forking (!), 'insubshell -u' would have no way of returning the same ID for the same subshell, which
	# defeats its purpose. So, to ensure a consistent state, use 'ulimit' to force a non-forked subshell to
	# fork whenever querying 'insubshell'. We can then simply use the generic method.
	_Msh_inSbSh_method='
		if ((.sh.subshell > 0)); then
			command ulimit -t unlimited 2>/dev/null
			(($# == 0)) && return 0
		fi
		'"${_Msh_inSbSh_generic_part1}${_Msh_inSbSh_generic_part2}"
else	# No shell-specific version available.
	_Msh_inSbSh_method=${_Msh_inSbSh_generic_part1}${_Msh_inSbSh_generic_part2}
fi
eval 'insubshell() {
	case ${#},${1-} in
	( 1,-p | 1,-u )  ;;
	( [!0]* ) die "insubshell: invalid arguments: $@" || return ;;
	esac
	'"${_Msh_inSbSh_method}"'
}'
unset -v _Msh_inSbSh_generic_part1 _Msh_inSbSh_generic_part2 _Msh_inSbSh_method

# Unconditionally make these names read-only, in order to:
# - reserve the names on shells without this functionality, to avoid cross-platform compatibility problems
# - disallow unsetting BASHPID on bash > 4.4.0, which would break insubshell() and lots of other stuff with it
# - enforce failure on assignment, instead of assignments having no effect, for BASHPID on bash > 4.4.0
#   (but note: bash still does not output any error message on assigning to a read-only BASHPID; instead,
#   it exits silently).
readonly BASHPID ZSH_SUBSHELL

# -------------

# Test if argument is valid portable variable (or shell function) name.
# Deals with empty removal. (This is why it doesn't take more than one argument.)
isvarname() {
	case ${#},${1-} in
	( [!01],* | ?[!,]* )
		_Msh_dieArgs isvarname "$#" '0 or 1' ;;
	( [01], | 1,[0123456789]* | 1,*[!"$ASCIIALNUM"_]* )
		return 1 ;;
	esac
}

# isset: Check if a variable, shell function or shell option is set.
# Usage: isset <varname>	# check if variable is set
#	 isset -v <varname>	# id.
#	 isset -x <varname>	# check if variable is exported
#	 isset -r <varname>	# check if variable is read-only
#	 isset -f <funcname>	# check if shell function is set
#	 isset -<optionletter>	# e.g. isset -C: check if shell option is set
#	 isset -o <optionname>	# check if shell option is set by long name
# This function deliberately does not check for nonexistent shell options, but
# instead returns a negative for a nonexistent option; this facilitates
# cross-platform scripting.
# (Note: just 'isset -f' checks if shell option -f (= -o noglob) is set, but
# with an extra argument, it checks if a shell function is set. Empty
# removal is an issue here if that argument is an empty unquoted variable,
# even under 'use safe'. An alternate syntax like isset --fn=<funcname>
# would be safer, but that's an ugly inconsistency with standard 'unset -f
# <funcname>'... As the current isset() syntax is nicely analogous with both
# 'set' and 'unset', I'm thinking we can put up with this minor issue.)
if thisshellhas BUG_IFSISSET; then
	# Workaround for BUG_IFSISSET in recent AT&T ksh93. For some reason they've made it impossible
	# to distinguish in any normal way between empty IFS and unset IFS. But this applies only to
	# IFS and no other variable, so we can figure it out by analysing field splitting behaviour.
	# No field splitting means empty IFS and default field splitting means unset IFS.
	_Msh_isset_BUG_IFSISSET='( 1,IFS, | 2,-v,IFS )			# BUG_IFSISSET workaround:
		case ${IFS:+n} in		# non-empty: it is set
		( "" )	set -- "a b"		# empty: test for default field splitting
			set -- $1
			let "$# == 1"		# no field splitting: it is empty and set
		esac ;;'
else
	_Msh_isset_BUG_IFSISSET=
fi
# ...isset -v
if thisshellhas DBLBRACKET; then
	if thisshellhas DBLBRACKETV; then
		_Msh_isset='[[ -v $1 ]]'
		_Msh_isset_v='[[ -v $2 ]]'
	else
		_Msh_isset='eval "[[ -n \${$1+s} ]]"'
		_Msh_isset_v='eval "[[ -n \${$2+s} ]]"'
	fi
else
	# default (POSIX) version
	_Msh_isset='eval "case \${$1+s} in ( '\'''\'' ) return 1 ;; esac"'
	_Msh_isset_v='eval "case \${$2+s} in ( '\'''\'' ) return 1 ;; esac"'
fi
# ...isset -x and isset -r
if isset ZSH_VERSION && ( eval ': ${(t)PATH}' ) 2>/dev/null; then
	# zsh makes this trivial: ${(t)VARNAME} (dash-separated) contains 'export', and
	# the P in ${(Pt)1} means: use the variable name stored in $1. Good thing too,
	# because 'export' on zsh is a reserved word we cannot alias (see below).
	#
	# Unfortunately, this does not work for unset readonly variables (zsh 5.0.8+) or unset exported
	# variables (zsh 5.3+), which only exist with POSIXBUILTINS active. Must have fallback for that.
	# For readonly, fall back to the simple assignment-in-subshell method. Exported unset variables
	# require examining the output 'export -p'. Thankfully, on zsh, 'export -p' quotes newlines and
	# always outputs one line per variable, so we can do the equivalent of simple grepping.
	_Msh_isset_x='case ${(P)2+s} in
		( s )	str in "-${(Pt)2}-" -export- ;;
		( * )	str in "$(export -p)$CCn" " $2$CCn" ;;
		esac'
	_Msh_isset_r='case ${(P)2+s} in
		( s )	str in "-${(Pt)2}-" -readonly- ;;
		( * )	! ( eval "$2=" ) 2>/dev/null ;;
		esac'
elif ! thisshellhas --rw=export; then
	# On other shells, we must use trickery to reliably parse the output of 'export -p'.
	# The 'export -p' command in POSIX shells produces 'export' commands (even on bash, as
	# long as the shell is in POSIX mode, which it must be to run modernish). Grepping this
	# output is not reliably possible because entries may be split in multiple lines. We
	# must get the shell to parse it. The only way to do this is to temporarily alias
	# 'export' to a handler function. This only works if 'export' is not a reserved word.
	_Msh_isset_x='unset -v _Msh_issetEx_WasRun _Msh_issetEx_FoundIt
		export "_Msh_issetExV=$2"	# guarantee one exported variable to check if this method works
		alias export=_Msh_issetExHandleExport
		eval "$(command export -p)"
		unalias export
		unset -v _Msh_issetExV
		isset _Msh_issetEx_WasRun && unset -v _Msh_issetEx_WasRun ||
			die "isset -x: internal error: '\''export -p'\'' not parseable or '\''export'\'' not aliasable" || return
		isset _Msh_issetEx_FoundIt && unset -v _Msh_issetEx_FoundIt'
	_Msh_issetExHandleExport() {
		_Msh_issetEx_WasRun=''
		case ${1%%=*} in
		("${_Msh_issetExV}") _Msh_issetEx_FoundIt='' ;;
		esac
	}
	# To find out if a variable is read-only, simply try to unset it in a subshell.
	_Msh_isset_r='! ( command unset -v "$2" || \exit 1 ) 2>/dev/null'	# BUG_TRAPSUB0 compat: explicit exit
else
	_Msh_initExit "init: isset -x: Can't determine method to test if a var. is exported." \
		"This shell has 'export' as a reserved word, but modernish was only" \
		"programmed to handle this on zsh. Please report this as a bug in modernish."
fi
# ...isset -f
if thisshellhas --bi=typeset &&
	command typeset -f isset >/dev/null 2>&1 &&
	! command typeset -f _Msh_nonExistentFunction >/dev/null 2>&1
then
	# bash, zsh, ksh93, mksh/pdksh, yash all have a 'typeset -f' that
	# returns with exit status 0 if the function is set, 1 if not.
	_Msh_isset_f='command typeset -f "$2" >/dev/null 2>&1'
else
	# Default (POSIX): compare output of 'command -V' against that of a known function.
	_Msh_fnOutput=$(command -V 'isset') || _Msh_initExit 'internal error (_Msh_fnOutput)'
	readonly "_Msh_fnOutput=${_Msh_fnOutput#*isset}"	# remove the function itself
	_Msh_isset_f='PATH=/dev/null command -v "$2" >/dev/null || return 1
		case $(command unalias "$2" 2>/dev/null; PATH=/dev/null command -V "$2") in
		( *"${_Msh_fnOutput}" )
			;;
		( * )	return 1 ;;
		esac'
fi
# ...isset -o
if thisshellhas DBLBRACKET; then
	if ! ( eval '[[ -o invalid@option ]] || :' ) 2>/dev/null; then
		# Shell exits on invalid [[ -o option ]] (zsh).
		_Msh_isset_o='( 2,-o,* ) thisshellhas -o "$2" && [[ -o $2 ]]'
	else
		_Msh_isset_o='( 2,-o,* ) [[ -o $2 ]]'
	fi
elif thisshellhas TESTO; then
	_Msh_isset_o='( 2,-o,* ) test -o "$2"'	# modernish hardened test()
else
	# Default (POSIX): compare output of 'set -o' with and without setting option.
	# - Expensive test: forks a subshell. This can't be avoided. In fact the straightforward method
	#   involves forking two command substitution subshells and comparing their output. Forking just
	#   one requires a hack involving a separator string, shell parameter substitutions, and defeating
	#   the command substitution's stripping of final linefeeds using a protector character (X).
	# - We're relying on 'set -o' output never containing "@_SEP_@"+newline,
	#   but that should be pretty safe as that's not a valid option name.
	# But first hand-map a few common long options to their short equivalents as an optimisation.
	_Msh_isset_o='( 2,-o,allexport )	isset -a ;;
	( 2,-o,interactive )	isset -i ;;
	( 2,-o,monitor )	isset -m ;;
	( 2,-o,noclobber )	isset -C ;;
	( 2,-o,noglob )		isset -f ;;
	( 2,-o,notify )		isset -b ;;
	( 2,-o,nounset )	isset -u ;;
	( 2,-o,verbose )	isset -v ;;
	( 2,-o,xtrace )		isset -x ;;
	( 2,-o,* ) thisshellhas -o "$2" || return
		{ _Msh_isset_o=$(set -o
				command -p echo @_SEP_@
				set +o "$2"		# subshell errors out here if opt does not exist
				set -o
				command -p echo X)
		} 2>/dev/null \
		&& ! str id "${_Msh_isset_o%@_SEP_@$CCn*}X" "${_Msh_isset_o#*@_SEP_@$CCn}" \
		&& unset -v _Msh_isset_o \
		|| ! unset -v _Msh_isset_o'
fi
# ...with all the code pieced together, define isset()
eval 'isset() {
	case ${#},${1-},${2-} in
	( 1,-o, )  die "isset -o: long-form option name expected" ;;
	( 1,-["$ASCIIALNUM"], )
		   case $- in ( *"${1#-}"* ) ;; ( * ) return 1 ;; esac ;;
	( 1,, | 1,[0123456789]* | 1,*[!"$ASCIIALNUM"_]*, \
	| 2,-[vxrf], | 2,-[vxrf],[0123456789]* | 2,-[vxrf],*[!"$ASCIIALNUM"_]* \
	| 2,-o, | 2,-o,*[!"$ASCIIALNUM"_-]* )
		   return 2 ;;  # invalid identifier
	'"${_Msh_isset_BUG_IFSISSET}"'
	( 1,* )    '"${_Msh_isset}"' ;;
	( 2,-v,* ) '"${_Msh_isset_v}"' ;;
	( 2,-x,* ) '"${_Msh_isset_x}"' ;;
	( 2,-r,* ) '"${_Msh_isset_r}"' ;;
	( 2,-f,* ) '"${_Msh_isset_f}"' ;;
	'"${_Msh_isset_o}"' ;;
	( 2,-* )   die "isset: invalid option: $2" ;;
	( * )	   die "isset: invalid arguments" ;;
	esac
}'"$CCn"
unset -v _Msh_isset_BUG_IFSISSET _Msh_isset _Msh_isset_v _Msh_isset_x _Msh_isset_r _Msh_isset_f _Msh_isset_o

# -------------

# Shell-quote the values of one or more variables to prepare them for
# safe use with "eval" or other parsing by the shell. If a value only
# contains shell-safe characters, it leaves it unquoted. Empty values
# are quoted.
#
# Usage: shellquote [ <options> ] <varname> ... [ [ <options> ] <varname> ... ]
#
# Options take effect for all variable names following them. Each option
# must be a separate argument.
# -f	Force quoting: disable size optimisations that allow unquoted characters.
# +f	Don't quote if value only contains shell-safe characters. (Default)
# -P	Generate POSIX Portable quoted strings, that may span multiple lines.
# +P	One-line quoted strings, double-quoting linefeeds with $CCn. (Default)
#
# Returns success (0) if all variables were processed successfully, and
# non-success (1) if any undefined (unset) variables were encountered.
#
# Ref.: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_02

# Internal function for shellquote() that POSIX-shellquotes one field (split by single quote).
# (Additive string assignment is faster on ksh93, bash and zsh, but slower on mksh/lksh.)
if case ${KSH_VERSION-}${BASH_VERSION-}${ZSH_VERSION-} in ('@(#)'* | '') ! :; esac \
&& thisshellhas ADDASSIGN; then
	_Msh_qV_sngQuote_do1fld() {
		# Unless -f was given, optimise for size by backslash-escaping single-character
		# fields and leaving fields containing only shell-safe characters unquoted.
		case ${_Msh_qV_f},${_Msh_qV_C} in
		( , | f, )
			_Msh_qV+=\\\' ;;
		( ,[!$CCn$SHELLSAFECHARS]* )
			# If the field starts with a single non-linefeed, non-shellsafe char and otherwise contains
			# nothing or only shellsafe chars, then backslash-escape it. Otherwise, single-quote.
			case ${_Msh_qV_C#?} in
			( *[!$SHELLSAFECHARS]* )
				_Msh_qV+=\'${_Msh_qV_C}\'\\\' ;;
			( * )	_Msh_qV+=\\${_Msh_qV_C}\\\' ;;
			esac ;;
		( ,*[!$SHELLSAFECHARS]* | f,* )
			# Non-shellsafe chars or -f: single-quote the field.
			_Msh_qV+=\'${_Msh_qV_C}\'\\\' ;;
		( * )	# Only shellsafe chars and no -f: don't quote.
			_Msh_qV+=${_Msh_qV_C}\\\' ;;
		esac
	}
else
	_Msh_qV_sngQuote_do1fld() {
		# Unless -f was given, optimise for size by backslash-escaping single-character
		# fields and leaving fields containing only shell-safe characters unquoted.
		case ${_Msh_qV_f},${_Msh_qV_C} in
		( , | f, )
			_Msh_qV=${_Msh_qV}\\\' ;;
		( ,[!$CCn$SHELLSAFECHARS]* )
			# If the field starts with a single non-linefeed, non-shellsafe char and otherwise contains
			# nothing or only shellsafe chars, then backslash-escape it. Otherwise, single-quote.
			case ${_Msh_qV_C#?} in
			( *[!$SHELLSAFECHARS]* )
				_Msh_qV=${_Msh_qV}\'${_Msh_qV_C}\'\\\' ;;
			( * )	_Msh_qV=${_Msh_qV}\\${_Msh_qV_C}\\\' ;;
			esac ;;
		( ,*[!$SHELLSAFECHARS]* | f,* )
			# Non-shellsafe chars or -f: single-quote the field.
			_Msh_qV=${_Msh_qV}\'${_Msh_qV_C}\'\\\' ;;
		( * )	# Only shellsafe chars and no -f: don't quote.
			_Msh_qV=${_Msh_qV}${_Msh_qV_C}\\\' ;;
		esac
	}
fi

# Internal function for shellquote() that single-quotes a string, possibly mixed
# with backslash quoting or leaving parts with only shellsafe characters unquoted.
_Msh_qV_sngQuote() {
	# Field-split the value at its single quote characters (at least 1, makes min. 2 fields).
	case ${_Msh_qV_VAL} in
	( *\' )	# On most shells, non-whitespace IFS discards a final empty field, so add one.
		thisshellhas QRK_IFSFINAL || _Msh_qV_VAL=${_Msh_qV_VAL}\' ;;
	esac
	_Msh_qV=
	push IFS -f; set -f
	IFS="'"; for _Msh_qV_C in ${_Msh_qV_VAL}; do IFS=
		# Quote each field, appending backslash-escaped literal single quotes.
		_Msh_qV_sngQuote_do1fld
	done
	pop IFS -f
	# End. Remove one superflous backslash-escaped single quote.
	_Msh_qV_VAL=${_Msh_qV%\\\'}
}

# Internal function for shellquote() to double-quote a string, replacing control
# characters with modernish $CC*. This guarantees a one-line, printable quoted string.
if thisshellhas PSREPLACE; then
	eval '_Msh_qV_dblQuote() {
		_Msh_qV=${_Msh_qV_VAL//\\/\\\\}
		_Msh_qV=${_Msh_qV//\$/\\\$}
		_Msh_qV=${_Msh_qV//\`/\\\`}
		case ${_Msh_qV_VAL} in
		( *[$CONTROLCHARS]* )
			_Msh_qV=${_Msh_qV//$CC01/'\''${CC01}'\''}
			_Msh_qV=${_Msh_qV//$CC02/'\''${CC02}'\''}
			_Msh_qV=${_Msh_qV//$CC03/'\''${CC03}'\''}
			_Msh_qV=${_Msh_qV//$CC04/'\''${CC04}'\''}
			_Msh_qV=${_Msh_qV//$CC05/'\''${CC05}'\''}
			_Msh_qV=${_Msh_qV//$CC06/'\''${CC06}'\''}
			_Msh_qV=${_Msh_qV//$CC07/'\''${CCa}'\''}
			_Msh_qV=${_Msh_qV//$CC08/'\''${CCb}'\''}
			_Msh_qV=${_Msh_qV//$CC09/'\''${CCt}'\''}
			_Msh_qV=${_Msh_qV//$CC0A/'\''${CCn}'\''}
			_Msh_qV=${_Msh_qV//$CC0B/'\''${CCv}'\''}
			_Msh_qV=${_Msh_qV//$CC0C/'\''${CCf}'\''}
			_Msh_qV=${_Msh_qV//$CC0D/'\''${CCr}'\''}
			_Msh_qV=${_Msh_qV//$CC0E/'\''${CC0E}'\''}
			_Msh_qV=${_Msh_qV//$CC0F/'\''${CC0F}'\''}
			_Msh_qV=${_Msh_qV//$CC10/'\''${CC10}'\''}
			_Msh_qV=${_Msh_qV//$CC11/'\''${CC11}'\''}
			_Msh_qV=${_Msh_qV//$CC12/'\''${CC12}'\''}
			_Msh_qV=${_Msh_qV//$CC13/'\''${CC13}'\''}
			_Msh_qV=${_Msh_qV//$CC14/'\''${CC14}'\''}
			_Msh_qV=${_Msh_qV//$CC15/'\''${CC15}'\''}
			_Msh_qV=${_Msh_qV//$CC16/'\''${CC16}'\''}
			_Msh_qV=${_Msh_qV//$CC17/'\''${CC17}'\''}
			_Msh_qV=${_Msh_qV//$CC18/'\''${CC18}'\''}
			_Msh_qV=${_Msh_qV//$CC19/'\''${CC19}'\''}
			_Msh_qV=${_Msh_qV//$CC1A/'\''${CC1A}'\''}
			_Msh_qV=${_Msh_qV//$CC1B/'\''${CCe}'\''}
			_Msh_qV=${_Msh_qV//$CC1C/'\''${CC1C}'\''}
			_Msh_qV=${_Msh_qV//$CC1D/'\''${CC1D}'\''}
			_Msh_qV=${_Msh_qV//$CC1E/'\''${CC1E}'\''}
			_Msh_qV=${_Msh_qV//$CC1F/'\''${CC1F}'\''}
			_Msh_qV=${_Msh_qV//$CC7F/'\''${CC7F}'\''} ;;
		esac
		_Msh_qV_VAL=\"${_Msh_qV//\"/\\\"}\"
	}'
else
	# Replacing arbitary characters with POSIX parameter substitutions is a
	# challenge. Use the algorithm from replacein() in the var/string module.
	_Msh_qV_R() {
		case ${_Msh_qV} in
		( *"$1"* )
			_Msh_qV_VAL=
			while case ${_Msh_qV} in ( *"$1"* ) ;; ( * ) ! : ;; esac; do
				_Msh_qV_VAL=${_Msh_qV_VAL}${_Msh_qV%%"$1"*}$2
				_Msh_qV=${_Msh_qV#*"$1"}
			done
			_Msh_qV=${_Msh_qV_VAL}${_Msh_qV} ;;
		esac
	}
	_Msh_qV_dblQuote() {
		_Msh_qV=${_Msh_qV_VAL}
		_Msh_qV_R \\ \\\\
		_Msh_qV_R \" \\\"
		_Msh_qV_R \$ \\\$
		_Msh_qV_R \` \\\`
		case ${_Msh_qV_VAL} in
		( *[$CONTROLCHARS]* )
			_Msh_qV_R "$CC01" \${CC01}
			_Msh_qV_R "$CC02" \${CC02}
			_Msh_qV_R "$CC03" \${CC03}
			_Msh_qV_R "$CC04" \${CC04}
			_Msh_qV_R "$CC05" \${CC05}
			_Msh_qV_R "$CC06" \${CC06}
			_Msh_qV_R "$CC07" \${CCa}
			_Msh_qV_R "$CC08" \${CCb}
			_Msh_qV_R "$CC09" \${CCt}
			_Msh_qV_R "$CC0A" \${CCn}
			_Msh_qV_R "$CC0B" \${CCv}
			_Msh_qV_R "$CC0C" \${CCf}
			_Msh_qV_R "$CC0D" \${CCr}
			_Msh_qV_R "$CC0E" \${CC0E}
			_Msh_qV_R "$CC0F" \${CC0F}
			_Msh_qV_R "$CC10" \${CC10}
			_Msh_qV_R "$CC11" \${CC11}
			_Msh_qV_R "$CC12" \${CC12}
			_Msh_qV_R "$CC13" \${CC13}
			_Msh_qV_R "$CC14" \${CC14}
			_Msh_qV_R "$CC15" \${CC15}
			_Msh_qV_R "$CC16" \${CC16}
			_Msh_qV_R "$CC17" \${CC17}
			_Msh_qV_R "$CC18" \${CC18}
			_Msh_qV_R "$CC19" \${CC19}
			_Msh_qV_R "$CC1A" \${CC1A}
			_Msh_qV_R "$CC1B" \${CCe}
			_Msh_qV_R "$CC1C" \${CC1C}
			_Msh_qV_R "$CC1D" \${CC1D}
			_Msh_qV_R "$CC1E" \${CC1E}
			_Msh_qV_R "$CC1F" \${CC1F}
			_Msh_qV_R "$CC7F" \${CC7F} ;;
		esac
		_Msh_qV_VAL=\"${_Msh_qV}\"
	}
fi

# Main shellquote function.
shellquote() {
	_Msh_qV_ERR=4
	_Msh_qV_f=
	_Msh_qV_P=
	for _Msh_qV_N do
		case ${_Msh_qV_N} in
		([+-]*)	_Msh_qV_ERR=4
			case ${_Msh_qV_N} in
			( -f )		_Msh_qV_f=f ;;
			( +f )		_Msh_qV_f= ;;
			( -P )		_Msh_qV_P=P ;;
			( +P )		_Msh_qV_P= ;;
			( -fP | -Pf )	_Msh_qV_f=f; _Msh_qV_P=P ;;
			( +fP | +Pf )	_Msh_qV_f=; _Msh_qV_P= ;;
			( * )		_Msh_qV_ERR=3; break ;;
			esac
			continue ;;
		( "" | [0123456789]* | *[!"$ASCIIALNUM"_]* )
			_Msh_qV_ERR=2
			break ;;
		esac
		! isset "${_Msh_qV_N}" && _Msh_qV_ERR=1 && break
		_Msh_qV_ERR=0
		eval "_Msh_qV_VAL=\${${_Msh_qV_N}}"

		# Determine quoting method based on options (f, P) and value, trying
		# to reduce exponential string growth when doing repeated quoting.
		case ${_Msh_qV_f}${_Msh_qV_P},${_Msh_qV_VAL} in	 # BUG_ISSETLOOP compat: don't use ${_Msh_qV_f+f}, etc.

		(  ,'[' |  ,']' |  ,'[[' |  ,']]' |  ,'{' |  ,'}' |  ,'{}' \
		| P,'[' | P,']' | P,'[[' | P,']]' | P,'{' | P,'}' | P,'{}' )
			# Unless -f was given, don't bother quoting these. They are used unquoted in
			# shell scripts all the time, and are only unsafe if part of larger strings.
			continue ;;

		( , | f, | fP, )
			# Quote empties.
			_Msh_qV_VAL="''" ;;

		( ,[!$CONTROLCHARS$SHELLSAFECHARS] | P,[!$CONTROLCHARS$SHELLSAFECHARS] )
			# No -f, a single non-ctrl, non-shellsafe char: backslash-escape.
			_Msh_qV_VAL=\\${_Msh_qV_VAL} ;;

		( ,\\[!$CONTROLCHARS$SHELLSAFECHARS] | P,\\[!$CONTROLCHARS$SHELLSAFECHARS] )
			# No -f, a single backslash-escaped non-ctrl, non-sellsafe char: double backslash-escape.
			_Msh_qV_VAL=\\\\${_Msh_qV_VAL} ;;

		( ,*[$CONTROLCHARS]* | f,*[$CONTROLCHARS]* )
			# No -P, some control char(s): double-quote to guarantee a printable one-line quoted string.
			_Msh_qV_dblQuote ;;

		( P,* | fP,* | *'\\'*'\\'*'\\'*'\\'*'\\'*'\\'*'\\'*'\\'* )
			# Either -P, or dblQuote would cause too much backslash growth: use mixed single/bksl quoting.
			_Msh_qV_sngQuote ;;

		( f,* | fP,* | *[!$SHELLSAFECHARS]* )
			# Otherwise, if -f given or any non-shellsafe chars, double-quote.
			_Msh_qV_dblQuote ;;

		( * )	# No -f and only shellsafe chars: no quoting needed.
			continue ;;
		esac

		eval "${_Msh_qV_N}=\${_Msh_qV_VAL}"
	done

	case ${_Msh_qV_ERR} in
	( 0 )	unset -v _Msh_qV _Msh_qV_C _Msh_qV_VAL _Msh_qV_f _Msh_qV_P _Msh_qV_N _Msh_qV_ERR ;;
	( 1 )	die "shellquote: unset variable: ${_Msh_qV_N}" ;;
	( 2 )	die "shellquote: invalid variable name: ${_Msh_qV_N}" ;;
	( 3 )	die "shellquote: invalid option: ${_Msh_qV_N}" ;;
	( 4 )	die "shellquote: expected variable(s) to quote" ;;
	( * )	die "shellquote: internal error (${_Msh_qV_ERR})" ;;
	esac
}

# Shell-quote all the positional parameters in-place.
# Usage: shellquoteparams (no arguments)
# To unquote them again, do:
#	eval "set -- $@"
# (be sure they are quoted before unquoting, or havoc will be wreaked!)
alias shellquoteparams='{ '\
'for _Msh_Q do'\
' shift && shellquote _Msh_Q && set -- "$@" "${_Msh_Q}" || die; '\
'done; '\
'unset -v _Msh_Q; }'

# ----------------

# Internal functions to support the shell options stack

# Internal function. Convert a long-form option name to short-form option
# letter, if it exists. Leaves the result in ${_Msh_o}. Returns status 0 if a
# corresponding short-form option letter exists, otherwise returns status 1.
unset -v _Msh_optLtrCache	# for caching results that require forking a subshell
_Msh_optNamToLtr() {
	case $1 in
	# hardcode option letters guaranteed by POSIX, plus 'i'
	( interactive )	_Msh_o=i ;;
	( allexport )	_Msh_o=a ;;
	( errexit )	_Msh_o=e ;;
	( noclobber )	_Msh_o=C ;;
	( noglob )	_Msh_o=f ;;
	( noexec )	_Msh_o=n ;;
	( nounset )	_Msh_o=u ;;
	( verbose )	_Msh_o=v ;;
	( xtrace )	_Msh_o=x ;;
	( nolog )	! unset -v _Msh_o ;; # BUG_OPTNOLOG compat (the test below fails on dash)
	# shell-specific option
	( * )	case ${_Msh_optLtrCache-}: in
		( *:"$1"=?:* )
			_Msh_o=${_Msh_optLtrCache#*:"$1"=}
			_Msh_o=${_Msh_o%%:*} ;;
		( *:!"$1":* )
			unset -v _Msh_o
			return 1 ;;
		( * )	# figure out if there is a letter for that long-form option
			_Msh_o=$(
				: 1>&1			# BUG_CSUBSTDO workaround
				set -o "$1" 2>/dev/null	# exits subshell with status > 0 if option does not exist
				_Msh_o1=$-
				set +o "$1" 2>/dev/null
				_Msh_o2=$-
				case $(( ${#_Msh_o1} - ${#_Msh_o2} )) in
				( 0 )	# option does not have a letter
					\exit 1 ;;
				( -* )	# the long option has an inverse effect to the letter option: swap values
					_Msh_o=${_Msh_o1}
					_Msh_o1=${_Msh_o2}
					_Msh_o2=${_Msh_o} ;;
				esac
				# for each char in ${_Msh_o1}, check if it occurs in ${_Msh_o2};
				# if it does NOT occur, we have found our letter
				while ! str empty "${_Msh_o1}"; do
					_Msh_o=${_Msh_o1%${_Msh_o1#?}}	# get first letter
					if ! str in "${_Msh_o2}" "${_Msh_o}"; then
						put "${_Msh_o}"
						\exit
					fi
					_Msh_o1=${_Msh_o1#?}
				done
				\exit 1
			) || {
				unset -v _Msh_o
				_Msh_optLtrCache=${_Msh_optLtrCache-}:!$1
				return 1
			}
			_Msh_optLtrCache=${_Msh_optLtrCache-}:$1=${_Msh_o} ;;
		esac
	esac
}

# Internal function. Validate and convert a long-form option name to its
# corresponding internal stack variable.
# Usage: _Msh_optNamToVar <optname> <varname> || die ...
_Msh_optNamToVar() {
	case $1 in
	( "" | *[!"$ASCIIALNUM"_-]* )
		return 1 ;;
	esac
	_Msh_V=$1
	if thisshellhas QRK_OPTCASE && str match "${_Msh_V}" '*[A-Z]*'; then
		_Msh_V=$(unset -f tr	# QRK_EXECFNBI compat
			putln "${_Msh_V}" | PATH=$DEFPATH LC_ALL=C exec tr A-Z a-z) \
		|| die '_Msh_optNamToVar: internal error' || return
	fi
	if thisshellhas QRK_OPTULINE; then
		while str in "${_Msh_V}" '_'; do	# remove '_'
			_Msh_V=${_Msh_V%%_*}${_Msh_V#*_}
		done
	fi
	if thisshellhas QRK_OPTDASH; then
		while str in "${_Msh_V}" '-'; do	# remove '-'
			_Msh_V=${_Msh_V%%-*}${_Msh_V#*-}
		done
	fi
	if _Msh_optNamToLtr "${_Msh_V}"; then
		eval "$2=_Msh_ShellOptLtr_\${_Msh_o}"
		unset -v _Msh_o
	else
		if str left "${_Msh_V}" "no" && thisshellhas OPTNOPREFIX -o "${_Msh_V#no}" -o "${_Msh_V}"; then
			_Msh_V=${_Msh_V#no}
		fi
		while str in "${_Msh_V}" '-'; do	# change any '-' to '_' in variable name
			_Msh_V=${_Msh_V%%-*}_${_Msh_V#*-}
		done
		eval "$2=_Msh_ShellOpt_\${_Msh_V}"
	fi
	unset -v _Msh_V
}

# ----------------

# Stack functions.
# Every variable has its own stack: simply do push VAR and pop VAR.
# Also works for saving/restoring shell options, e.g.: push -f; pop -f
# Uses global variable namespace: _Msh__V*__S*
#
# Features:
#	- Saves and restores not just value, but set/unset state.
#	- Stack size is limited by memory or shell constraints only.
#	- Fast: does not launch any subshell or external process.
#	- Cleans up after itself: leaves no trace in the environment upon
#         empty stack.
#	- Matches long-form shell options to short-form shell options;
#	  for instance, "push -o noglob; pop -f" works correctly.
#	  This works even for shell-specific options.
#
# Use cases:
#	- Easily store lots of arbitary data to use later.
#	- Code blocks (not just functions) with 'fake' local variables
#	  and/or shell options. See also the var/local module.
#	- Easy temporary field splitting ('push IFS' and 'pop IFS' work fine).

# --- push ---
# Push each variable's value or shell option setting on its respective stack.
# Usage: push [ --key=<value> ] <item> [ <item> ...]
#	 where <item> is a variable name, shell option (dash plus letter),
#	 or long-form shell option (two arguments, '-o' and option name).
#
# If the "--key=<value>" option is given, then for each <item>, the given
# key value is stored along with the variable's value for that position in
# the stack. Popping that value will only succeed if the same key is given
# with the 'pop' invocation. This feature helps different functions to use
# the same variable stack safely.
push() {
	# Exporting the stack would be bad; run 'push' without 'set -a' active.
	# Save the status of 'set -a' in a variable so 'push -a' works.
	# Also parse the key option, if any.
	case ${#},${1-},${-} in
	( 0,* | 1,--key=* )
		die "push: needs at least 1 non-option argument" || return ;;
	( *,"--key=${1#--key=}",*a* )
		_Msh_push_key=${1#--key=}; set +a; _Msh_push_opta=y; shift ;;
	( *,--key=*,"${-}" )
		_Msh_push_key=${1#--key=}; unset -v _Msh_push_opta; shift ;;
	( *,"$1",*a* )
		unset -v _Msh_push_key; set +a; _Msh_push_opta=y ;;
	( * )	unset -v _Msh_push_opta _Msh_push_key ;;
	esac

	# Validate variable names and shell options before doing anything. Portable shell varname
	# constraints apply. Long option names may also start with digit and contain '-'.
	_Msh_push_err=0
	unset -v _Msh_o
	for _Msh_push_V do
		case ${_Msh_o-} in		# BUG_ISSETLOOP compat: don't use ${_Msh_o+s}
		( y )	unset -v _Msh_o
			case ${_Msh_push_V} in
			( "" | *[!"$ASCIIALNUM"_-]* )
				_Msh_push_err=101
				break ;;
			esac ;;
		( * )	case ${_Msh_push_V} in
			( -o )	_Msh_o=y	# expect another argument
				continue ;;
			( -["$ASCIIALNUM"] )
				;;		# short-form shell option: ok
			( '' | [0123456789]* | *[!"$ASCIIALNUM"_]* )
				_Msh_push_err=101
				break ;;
			esac ;;
		esac
	done
	case ${_Msh_o-} in
	( y )	_Msh_push_err=100 ;;
	esac

	# Do the job.
	case ${_Msh_push_err} in
	( 0 ) for _Msh_push_V do
		# Long-form shell option:
		case ${_Msh_o-} in
		( y )	_Msh_push_o=${_Msh_push_V}
			_Msh_optNamToVar "${_Msh_push_o}" _Msh_push_V || { _Msh_push_err=103; break; }
			case ${_Msh_push_V} in
			( _Msh_ShellOptLtr_a )
				isset _Msh_push_opta ;;
			( _Msh_ShellOptLtr_? )
				isset -${_Msh_push_V#_Msh_ShellOptLtr_} ;;
			( * )	isset -o "${_Msh_push_o}" ;;
			esac && eval "${_Msh_push_V}=''" || unset -v "${_Msh_push_V}"
			unset -v _Msh_push_o ;;
		esac
		# Short-form shell option or '-o':
		case ${_Msh_push_V} in
		( -o )	_Msh_o=y	# expect another argument
			continue ;;
		( -a )	case ${_Msh_push_opta+s} in
			( s )	_Msh_ShellOptLtr_a='' ;;
			( * )	unset -v _Msh_ShellOptLtr_a ;;
			esac
			_Msh_push_V='_Msh_ShellOptLtr_a'
			;;
		( -? )	_Msh_push_V=${_Msh_push_V#-}
			case $- in
			( *${_Msh_push_V}* )
				eval "_Msh_ShellOptLtr_${_Msh_push_V}=''" ;;
			( * )	unset -v "_Msh_ShellOptLtr_${_Msh_push_V}" ;;
			esac
			_Msh_push_V="_Msh_ShellOptLtr_${_Msh_push_V}"
			;;
		esac

		# Initialize/validate stack pointer.
		eval "_Msh_push_SP=\${_Msh__V${_Msh_push_V}__SP=0}"
		case ${_Msh_push_SP} in
		( '' | *[!0123456789]* ) _Msh_push_err=102; break ;;
		esac

		# Store value or unset status.
		if isset "${_Msh_push_V}"; then
			eval "_Msh__V${_Msh_push_V}__S${_Msh_push_SP}=\$${_Msh_push_V}"
		else
			unset -v "_Msh__V${_Msh_push_V}__S${_Msh_push_SP}"
		fi

		# Store key, if any.
		case ${_Msh_push_key+s} in
		( s )	eval "_Msh__V${_Msh_push_V}__K${_Msh_push_SP}=\${_Msh_push_key}" ;;
		( * )	unset -v "_Msh__V${_Msh_push_V}__K${_Msh_push_SP}" ;;
		esac

		# Increase stack pointer for next item on stack.
		_Msh_push_SP=$((_Msh__V${_Msh_push_V}__SP += 1))
	done;; esac
	case ${_Msh_push_opta+s} in
	( s )	set -a; unset -v _Msh_push_opta ;;
	esac
	case ${_Msh_push_err} in
	( 100 )	die "push -o: long-form option name expected" ;;
	( 101 ) die "push: invalid variable name or shell option: ${_Msh_push_V}" ;;
	( 102 ) die "push: Stack pointer for ${_Msh_push_V} corrupted" ;;
	( 103 ) die "push: internal error" ;;
	esac || return
	eval "unset -v _Msh_push_V _Msh_push_SP _Msh_push_err _Msh_push_key; return ${_Msh_push_err}"
}

# --- pop ---
# Pop each variable or shell option's last state off the stack and restore it.
#
# Usage: pop [ --keepstatus ] [ --key=<value> ] <item> [ <item> ... ]
#	 where <item> is a variable name, shell option (dash plus letter),
#	 or long-form shell option (two arguments, '-o' and option name).
#
# If the "--keepstatus" option is given, pop() will exit with the exit status
# of the command executed immediately prior to calling pop(). This can be
# helpful when restoring variables or shell options at the end of a function.
# However, note that this makes failure to pop (stack empty or key mismatch)
# a fatal error, as pop() no longer has a way to communicate this through its
# exit status.
#
# If the "--key=<value>" option is given, then for each <item>, the given key
# value is matched against the stored key value for that position in the stack.
# If there is any mismatch, no changes are made and pop returns status 2. The
# key feature helps different functions to use the same variable stack safely.
#
# Returns unsuccessfully without changing anything if *any* of the stacks
# for the specified variables or shell options is empty or has a key mismatch.
# Either all get popped, or none. This helps provide validation against stack
# inconsistency for groups of variables that should be pushed/popped together.
if thisshellhas BUG_ARITHTYPE; then
	if thisshellhas typeset && typeset -g +i _Msh_test 2>/dev/null; then
		# BUG_ARITHTYPE (older zsh) workaround: unset a possible integer
		# type restriction caused earlier by arithmetic assignment.
		_Msh_pop_BUG_ARITHTYPE_workaround='typeset -g +i "${_Msh_pop_V}"; '
	else
		_Msh_initExit 'init: pop: cannot determine BUG_ARITHTYPE workaround' \
			"This shell has BUG_ARITHTYPE but does not appear to be zsh. Modernish" \
			"was not programmed to handle this; please report his as a bug."
	fi
else
	unset -v _Msh_pop_BUG_ARITHTYPE_workaround
fi
pop() {
	_Msh_pop_oldstatus=$?	# BUG_CASESTAT compat
	case ${#},${1-},${2-} in
	( 0, | 1,--keepstatus, | 2,--keepstatus,--key=* | 2,--key=*,--keepstatus )
		die "pop: needs at least 1 non-option argument" || return ;;
	( *,--keepstatus,--key=* )
		_Msh_pop_key=${2#--key=}; shift 2 ;;
	( *,--key=*,--keepstatus )
		_Msh_pop_key=${1#--key=}; shift 2 ;;
	( *,--keepstatus,* )
		unset -v _Msh_pop_key; shift ;;
	( *,--key=*,* )
		_Msh_pop_key=${1#--key=}; unset -v _Msh_pop_oldstatus; shift ;;
	( * )	unset -v _Msh_pop_key _Msh_pop_oldstatus ;;
	esac

	# Exporting the stack would be bad; run "pop" without "set -a" active.
	# Save the status of "set -a" in a variable so "pop -a" works.
	case $- in
	( *a* )	set +a; _Msh_pop_opta=y ;;
	( * )	unset -v _Msh_pop_opta ;;
	esac

	# Validate everything before doing anything.
	_Msh_pop_err=0
	unset -v _Msh_o
	for _Msh_pop_V do
		case ${_Msh_o-} in		# BUG_ISSETLOOP compat: don'\''t use ${_Msh_o+s}
		( y )	unset -v _Msh_o
			_Msh_optNamToVar "${_Msh_pop_V}" _Msh_pop_V || { _Msh_pop_err=101; break; } ;;
		( * )	case ${_Msh_pop_V} in
			( -o )	_Msh_o=y	# expect another argument
				continue ;;
			( -["$ASCIIALNUM"] )
				_Msh_pop_V="_Msh_ShellOptLtr_${_Msh_pop_V#-}" ;;
			( "" | [0123456789]* | *[!"$ASCIIALNUM"_]* )
				_Msh_pop_err=101
				break ;;
			esac ;;
		esac

		# Check for stack empty
		eval "_Msh_pop_SP=\${_Msh__V${_Msh_pop_V}__SP+s},\${_Msh__V${_Msh_pop_V}__SP-}"
		case ${_Msh_pop_SP} in
		( , )	_Msh_pop_err=$((_Msh_pop_err<1 ? 1 : _Msh_pop_err)); continue ;;
		( s, | s,0* | s,*[!0123456789]* )
			_Msh_pop_err=102; continue ;;
		esac

		# Match stored key against given key
		_Msh_pop_SP=$((_Msh__V${_Msh_pop_V}__SP - 1))
		eval "case \${_Msh_pop_key+k},\${_Msh_pop_key-},\${_Msh__V${_Msh_pop_V}__K${_Msh_pop_SP}+s} in
		( ,, | k,\"\${_Msh__V${_Msh_pop_V}__K${_Msh_pop_SP}-}\",s )
			;;
		( * )	_Msh_pop_err=\$((_Msh_pop_err<2 ? 2 : _Msh_pop_err)) ;;
		esac"
	done
	case ${_Msh_o-} in
	( y )	_Msh_pop_err=100 ;;	# -o without long option name
	esac

	# Do the job.
	case ${_Msh_pop_err} in
	( 0 ) for _Msh_pop_V do
		# Convert long-form shell option to short form if available, then to variable
		case ${_Msh_o-} in
		( y )	_Msh_pop_o=${_Msh_pop_V}
			_Msh_optNamToVar "${_Msh_pop_V}" _Msh_pop_V || { _Msh_pop_err=103; break; } ;;
		esac

		# If shell option, translate to internal variable.
		case ${_Msh_pop_V} in
		( -o )	_Msh_o=y	# expect another argument
			continue ;;
		( -? )	_Msh_pop_V="_Msh_ShellOptLtr_${_Msh_pop_V#-}" ;;
		esac

		# Decrease stack pointer so it points to the item to pop.
		_Msh_pop_SP=$((_Msh__V${_Msh_pop_V}__SP -= 1))

		# Restore value or unset status.
		if isset "_Msh__V${_Msh_pop_V}__S${_Msh_pop_SP}"; then
			eval "${_Msh_pop_BUG_ARITHTYPE_workaround-}${_Msh_pop_V}=\${_Msh__V${_Msh_pop_V}__S${_Msh_pop_SP}}"
		else
			unset -v "${_Msh_pop_V}"
		fi

		# Clean up: unset the stack variable we just popped off the stack, and its key (if any).
		unset -v "_Msh__V${_Msh_pop_V}__S${_Msh_pop_SP}" "_Msh__V${_Msh_pop_V}__K${_Msh_pop_SP}"

		# Clean up: if the stack is empty, unset the stack pointer.
		case ${_Msh_pop_SP} in
		( 0 )	unset -v "_Msh__V${_Msh_pop_V}__SP" _Msh_pop_SP ;;
		esac

		# If it's a shell option variable, restore the shell option.
		case ${_Msh_pop_V} in
		( _Msh_ShellOptLtr_a )
			case ${_Msh_ShellOptLtr_a+s} in
			( s )	_Msh_pop_opta=y
				unset -v _Msh_ShellOptLtr_a ;;
			( * )	unset -v _Msh_pop_opta ;;
			esac
			;;
		( _Msh_ShellOptLtr_[bcdefghijklmnpqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ] )
			if isset "${_Msh_pop_V}"; then
				isset "-${_Msh_pop_V#_Msh_ShellOptLtr_}" || set "-${_Msh_pop_V#_Msh_ShellOptLtr_}"
				unset -v "${_Msh_pop_V}"
			else
				isset "-${_Msh_pop_V#_Msh_ShellOptLtr_}" && set "+${_Msh_pop_V#_Msh_ShellOptLtr_}"
			fi
			;;
		( _Msh_ShellOpt_?* )
			if isset "${_Msh_pop_V}"; then
				isset -o "${_Msh_pop_o}" || set -o "${_Msh_pop_o}"
				unset -v "${_Msh_pop_V}"
			elif isset -o "${_Msh_pop_o}"; then
				isset -o "${_Msh_pop_o}" && set +o "${_Msh_pop_o}"
			fi
			unset -v _Msh_pop_o ;;
		esac
	done;; esac
	case ${_Msh_pop_opta+s} in
	( s )	set -a; unset -v _Msh_pop_opta ;;
	esac
	case ${_Msh_pop_err} in
	( 100 )	die "pop -o: long-form option name expected" ;;
	( 101 ) die "pop: invalid variable name or shell option: ${_Msh_pop_V}" ;;
	( 102 ) die "pop: Stack pointer for ${_Msh_pop_V} corrupted" ;;
	( 103 ) die "pop: internal error" ;;
	esac || return
	case ${_Msh_pop_oldstatus+s} in
	( s )	eval "unset -v _Msh_pop_V _Msh_pop_SP _Msh_pop_err _Msh_pop_oldstatus _Msh_pop_key
		case ${_Msh_pop_err} in
		( 0 )	;;
		( * )	die \"pop --keepstatus: fatal: couldn'\''t pop \$@${_Msh_pop_SP+${_Msh_pop_key+ (key mismatch)}}\"
			return ;;
		esac
		return ${_Msh_pop_oldstatus}" ;;
	( * )	eval "unset -v _Msh_pop_V _Msh_pop_SP _Msh_pop_err _Msh_pop_key; return ${_Msh_pop_err}" ;;
	esac
}

# -------------

# 'putln' and 'put'
#
# 'putln' prints each argument on a separate line. 'put' prints all arguments,
# separated by spaces, without a trailing newline. There is no processing of
# options, '--', escape codes, or any other potential pitfalls.
#
# These functions are the modernish replacement for 'echo', which is deprecated.
# POSIX: "It is not possible to use echo portably across all POSIX systems
# unless both -n (as the first argument) and escape sequences are omitted."
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/echo.html#tag_20_37_16

if thisshellhas print KSH88FUNC; then
	# pdksh and mksh don't have a 'printf' builtin, and using the external
	# 'printf' command is very slow. But they do have a built-in
	# ksh/zsh-style 'print' command, so here are versions of 'putln' and
	# 'put' that take advantage of it to get much higher performance.
	putln() {
		case $# in
		( 0 )	command print ;;
		( 1 )	command print -r -- "$1" ;;
		( * )	typeset IFS="$CCn" && command print -r -- "$*" ;;
		esac || { let "$? > 1" && die "putln: internal error"; }
	}

	put() {
		case ${#},${1-} in
		( [01], ) ;;
		( 1,* )  command print -nr -- "$1" ;;
		( * )	 typeset IFS=' ' && command print -nr -- "$*" ;;
		esac || { let "$? > 1" && die "put: internal error"; }
	}

else
	# For most shells, use 'printf' for putln and put.
	# 'printf' could be an external command, so tolerate SIGPIPE.
	putln() {
		case $# in
		( 0 )	PATH=$DEFPATH command printf '\n' ;;
		( * )	PATH=$DEFPATH command printf '%s\n' "$@" ;;
		esac || { let "$? > 1 && $? != SIGPIPESTATUS" && die "putln: internal error"; }
	}

	if thisshellhas LOCALVARS local; then
		# bash, ash variants, zsh
		put() {
			case ${#},${1-} in
			( [01], ) ;;
			( 1,* )  PATH=$DEFPATH command printf '%s' "$1" ;;
			( * )	 local IFS=' ' && PATH=$DEFPATH command printf '%s' "$*" ;;
			esac || { let "$? > 1 && $? != SIGPIPESTATUS" && die "put: internal error"; }
		}
	elif thisshellhas KSH93FUNC || thisshellhas KSH88FUNC; then
		# AT&T ksh93; yash (non-posixlycorrect)
		# On ksh93, local variables are only supported on functions
		# defined with the 'function' keyword. Use 'eval' to avoid
		# syntax error on shells without that keyword.
		eval 'function put {
			case ${#},${1-} in
			( [01], ) ;;
			( 1,* )  PATH=$DEFPATH command printf "%s" "$1" ;;
			( * )	 typeset IFS=" " && PATH=$DEFPATH command printf "%s" "$*" ;;
			esac || { let "$? > 1 && $? != SIGPIPESTATUS" && die "put: internal error"; }
		}'
	else
		# default (POSIX, no local variables)
		put() {
			case ${#},${1-} in
			( [01], ) ;;
			( 1,* )  PATH=$DEFPATH command printf '%s' "$1" ;;
			( * )	 push IFS; IFS=' '
				 PATH=$DEFPATH command printf '%s' "$*"
				 pop --keepstatus IFS ;;
			esac || { let "$? > 1 && $? != SIGPIPESTATUS" && die "put: internal error"; }
		}
	fi
fi

# -------------

# 'source' as in zsh and bash, with optional positional parameters, now also
# available to (d)ash, yash and *ksh*. If extra arguments are given, they
# are passed to the dot script as local positional parameters as in a shell
# function; if not, the dot script inherits the calling environment's
# positional parameters (unlike a shell function).
#
# In pure POSIX shells, '.' cannot pass extra arguments, and dot scripts
# always inherit the caller's positional parameters; this can be worked
# around with a shell function. However, this is implementation-dependent;
# in bash, *ksh* and zsh, '.' does pass the parameters. Modernish scripts
# should use 'source' instead of '.' for consistent functionality.
if ! thisshellhas source; then
	alias source='_Msh_doSource "$#" "$@"'
	_Msh_doSource() {
		let "$# > ( $1 + 1 )" || _Msh_dieArgs source 0 'at least 1' || return
		eval "_Msh_source_S=\${$(( $1 + 2 ))}"

		if let "$# > ( $1 + 2 )"; then
			# extra arguments were given; discard the number of caller's positional parameters, the
			# caller's positional parameters themselves, and the argument indicating the dot script
			shift "$(( $1 + 2 ))"
		else
			# no extra arguments were given; keep caller's positional parameters, but remove the number
			# of them (first parameter) and the argument indicating the dot script (last parameter)
			_Msh_source_P=''
			_Msh_source_i=1
			while let "(_Msh_source_i+=1) < $#"; do
				_Msh_source_P="${_Msh_source_P} \"\${${_Msh_source_i}}\""
			done
			eval "set -- ${_Msh_source_P}"
			unset -v _Msh_source_P _Msh_source_i
		fi

		# Unlike '.', find the dot script in the current directory, not just in $PATH.
		case ${_Msh_source_S} in
		( */* ) ;;
		( * )	if is -L reg "${_Msh_source_S}"; then
				_Msh_source_S=./${_Msh_source_S}
			fi ;;
		esac

		. "${_Msh_source_S}"
		eval "unset -v _Msh_source_S; return $?"
	}
fi

# -------------

# To mitigate the risk of 'test'/'[' brittleness causing legacy shell scripts incorporating modernish to continue in an
# inconsistent state, harden the 'test' and '[' commands. We use the fact that, if implemented correctly, it exits with
# status > 1 (usually 2) on error (such as a syntax error due to unexpected split/glob or empty removal). This will not
# catch all problems, such as the [ -n $empty ] or [ -e $empty ] false positives. BUG_TESTERR{0,1A,1B} also kills this.

test() {
	PATH=$DEFPATH command test "$@" \
	|| ! case $? in
	( 1 )	;;
	( * )	shellquoteparams; die "command failed: test $@" ;;
	esac
}
if command alias "[=_Msh_hardenBracket" 2>/dev/null; then
	# We cannot use '[' as a function name, but every supported shell except AT&T ksh93 can alias '['.
	_Msh_hardenBracket() {
		PATH=$DEFPATH command [ "$@" \
		|| ! case $? in
		( 1 )	;;
		( * )	shellquoteparams; die "command failed: [ $@" ;;
		esac
	}
fi
unset -v _Msh_test_TESTILNUM

# -------------

# Safer replacement functions for 'test'/'['
# Rationale: see README.md

# ---- Arithmetic tests and operations. ----
# Implementation of 'let' as in ksh, bash, zsh and busybox ash, for shells
# without it.
# Usage: let <expr> [ <expr> ... ]
# where <expr> is an arithmetic expression as in $(( ... )).
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_04
#
# The exit status is 1 if the last expression evaluates to 0, and 0 if not.
# (0 and 1 in C-style boolean are the opposite of 0 and 1 in shell boolean, so
# this means it does the right true-or-false thing for the shell.)
#
# Shells immediately exit on arith evaluation error, so the usual "|| die"
# check on errors is ineffective.
#
# There are two portability problems with 'let' builtins:
#   1.	On AT&T ksh, the first expression cannot start with a '-' as it will
#	be interpreted as an option, even though its "let" doesn't have any
#	valid options. The end-of-options delimeter '--' is needed for the
#	first expression to start with '-'. However, on pdksh/mksh and
#	Busybox ash, '--' is not accepted and will throw a syntax error.
#	These situations are irreconcilable without a workaround.
#	(Bash and zsh accept '--' but don't require them, even if the first
#	expression starts with '-'.)
#   2.  Some ash derivatives (such as FreeBSD /bin/sh) have an undocumented
#	and incompatible 'let' builtin that only takes one expression (and
#	uselessly outputs the result to standard output).
# So let's test if we have a version that works as expected and override the
# builtin if it's not up to scratch.
unset -v _Msh_X _Msh_Y _Msh_goodlet
if thisshellhas let; then
	if let -- -1\<0 _Msh_X=1 _Msh_Y=_Msh_X+3 \
	&& case ${_Msh_X-},${_Msh_Y-} in ( 1,4 ) ;; ( * ) false ;; esac \
	&& unset -v _Msh_X _Msh_Y
	then
		# Workaround for AT&T ksh to make things like 'let -1==var' or 'let --var' work.
		# For consistency, also use '--' on other shells whose 'let' builtin supports it;
		# this makes sure 'let' in modernish scripts does not accept '--' on any shell,
		# instead of accepting it on some shells but not on others.
		alias let='let --'
		_Msh_goodlet=y
	elif let -1\<0 _Msh_X=1 _Msh_Y=_Msh_X+3 \
	&& case ${_Msh_X-},${_Msh_Y-} in ( 1,4 ) ;; ( * ) false ;; esac \
	&& unset -v _Msh_X _Msh_Y
	then
		# Use the builtin as is: mksh/lksh, Busybox ash
		_Msh_goodlet=y
	fi
fi 2>/dev/null
case ${_Msh_goodlet+s} in
( s )	if let 014!=12 && thisshellhas -o letoctal; then
		set -o letoctal  # make AT&T ksh act like other shells
	fi
	unset -v _Msh_goodlet ;;
( * )	# We're on a shell with a missing or incompatible 'let' builtin, so provide our own. Optimise
	# it by processing up to 4 expressions at once. This modernish version, like pdksh/mksh and
	# Busybox ash, does not accept the '--' end-of-options delimiter.
	# (Using 'eval' to avoid syntax error in case an alias let='let --' was set above.)
	eval 'let() {
		case $# in
		( 1 )	return "$((!($1)))" ;;
		( 2 )	: "$(($1))"
			return "$((!($2)))" ;;
		( 3 )	: "$(($1))$(($2))"
			return "$((!($3)))" ;;
		( 4 )	: "$(($1))$(($2))$(($3))"
			return "$((!($4)))" ;;
		( 0 )	die "let: expression expected" ;;
		( * )	: "$(($1))$(($2))$(($3))$(($4))"
			shift 4
			let "$@" ;;
		esac
	}' ;;
esac

# ---- String tests. ----
# str null/id/in/left/right/match/ematch/isint

# Determine code for glob pattern test.
# Usage: str match <string> <glob-pattern>
# Empty removal handling: if one argument is omitted, assume the first was a
# removed unquoted empty parameter and return false. 0 arguments = fatal error.
if thisshellhas DBLBRACKET; then
	_Msh_doMatch='[[ $2 == $3 ]]'
else
	_Msh_doMatch='case $2 in ( $3 ) ;; ( * ) return 1 ;; esac'
fi
# Check if the shell can reliably pass backslash-escaped characters from a parameter.
# (bash < 5.0 has trouble with backslash-escaped $CC01 and $CC7F specifically.)
_Msh_match_backslash=
eval "_Msh_tmp_match() { ${_Msh_doMatch}; }"
if ! _Msh_tmp_match - "? *x${CC01}y${CC7F}z" "??\\*\\x\\${CC01}\\y\\${CC7F}\\z"; then
	# Shell does not support passing backslash-escaped characters from a variable. Need to parse
	# patterns containing backslashes as string literals, which requires making the pattern
	# string safe for 'eval'. Only bother with this if the pattern in fact contains a backslash.
	if thisshellhas DBLBRACKET; then
		_Msh_doMatchEval='[[ \$2 == ${_Msh_Q} ]]'
	else
		_Msh_doMatchEval='case \$2 in ( ${_Msh_Q} ) ;; ( * ) return 1 ;; esac'
	fi
	_Msh_match_backslash='( *\\* )
			_Msh_Q=
			_Msh_P=$3
			while :; do
				case ${_Msh_P} in
				( "" )	break ;;
				# Handle newline specially with a ref to $CCn.
				($CCn*)	_Msh_Q=${_Msh_Q}\${CCn}
					_Msh_P=${_Msh_P#?} ;;
				# Handle backslash-escaped newline specially with a ref to $CCn.
				(\\$CCn*)_Msh_Q=${_Msh_Q}\${CCn}
					_Msh_P=${_Msh_P#??} ;;
				# Leave other backslash-escaped characters alone.
				(\\?*)	_Msh_Q=${_Msh_Q}${_Msh_P%"${_Msh_P#??}"}
					_Msh_P=${_Msh_P#??} ;;
				# Leave unescaped glob characters and shell-safe characters alone.
				([][?*]* | ["$SHELLSAFECHARS"]*)
					_Msh_Q=${_Msh_Q}${_Msh_P%"${_Msh_P#?}"}
					_Msh_P=${_Msh_P#?} ;;
				# Backslash-escape everything else.
				( * )	_Msh_Q=${_Msh_Q}\\${_Msh_P%"${_Msh_P#?}"}
					_Msh_P=${_Msh_P#?} ;;
				esac
			done
			eval "unset -v _Msh_P _Msh_Q; '"${_Msh_doMatchEval}"'" ;; '
fi
unset -f _Msh_tmp_match
# For a dangling final backslash, ensure the same behaviour on all shells because "if a pattern ends with
# an unescaped <backslash>, it is unspecified whether the pattern does not match anything or the pattern is
# treated as invalid". (In fact, some shells do neither and match it as if it were an escaped backslash).
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_13_01
_Msh_doMatch='case $3 in
	( \\ | *[!\\]\\ )
		return 2 ;;
	'"${_Msh_match_backslash}"'
	( * )	'"${_Msh_doMatch}"' ;;
	esac'

# Determine code for extended regular expression test.
# Usage: str ematch <string> <extended-regex>
#
# Use the [[ keyword (or '[' on yash) if available and if it supports
# extended regular expressions. This is much faster than the standard method
# which involves invoking the external grep command.
#
# Empty removal handling: if one argument is omitted, assume the first was a
# removed unquoted empty parameter and return false. 0 arguments = fatal error.
if thisshellhas DBLBRACKETERE; then
	# Wrap the function definition in 'eval', otherwise shells that
	# have '[[' but don't support '=~' fail to parse the script.
	_Msh_doEMatch='[[ $2 =~ $3 ]]'
elif thisshellhas --bi=test && ( PATH=$DEFPATH command test aaa '=~' '^a{2,}$' ) 2>/dev/null; then
	# yash and zsh support extended regex matching in builtin test/[
	# (the test needs subshell on zsh in case its regex module fails to load)
	_Msh_doEMatch='test "$2" "=~" "$3"'
else
	# Default/POSIX: use awk's match().
	_Msh_doEMatch='PATH=$DEFPATH POSIXLY_CORRECT=y _Msh_V=$2 _Msh_R=$3 command awk \
			'\''BEGIN { exit(!match(ENVIRON["_Msh_V"],ENVIRON["_Msh_R"])); }'\'' \
		|| { let "$? > 1" && die "str ematch: '\''awk'\'' failed"; }'
fi

# Determine code for lexical comparison.
# ...	If we're running on bash, ksh or zsh:
if thisshellhas DBLBRACKET; then
	_Msh_doSortsBefore='[[ $2 < $3 ]]'
	_Msh_doSortsAfter='[[ $2 > $3 ]]'
# ...	Try to fall back to builtin '['/'test' non-standard feature.
#	Thankfully, '<' and '>' are pretty widely supported for this builtin. Unlike with [[ ]],
#	we need to quote everything. (Note that test() is a 'test' hardened in bin/modernish.)
elif thisshellhas --bi=test \
&& PATH=$DEFPATH command test "a${CCn}b" '<' "a${CCn}bb" 2>/dev/null \
&& PATH=$DEFPATH command test "a${CCn}bb" '>' "a${CCn}b" 2>/dev/null
then
	_Msh_doSortsBefore='test "X$1" "<" "X$2"'
	_Msh_doSortsAfter='test "X$1" ">" "X$2"'
# ...	Fall back to the POSIX way with the external expr(1) utility.
else
	_Msh_doSortsBefore='PATH=$DEFPATH command expr "X$1" "<" "X$2" >/dev/null \
		|| { let "$? > 1" && die "str lt: '\''expr'\'' failed"; }'
	_Msh_doSortsAfter='PATH=$DEFPATH command expr "X$1" ">" "X$2" >/dev/null \
		|| { let "$? > 1" && die "str gt: '\''expr'\'' failed"; }'
fi

# Define the main str() function.
eval 'str() {
	case ${#},$1 in
	( 1,empty | 1,id | 1,isint )
			;;		# assume removed unquoted argument(s)
	( 2,id | 2,in | 2,left | 2,right | 2,match | 2,ematch )
			return 1 ;;	# assume removed unqoted pattern
	( 2,empty )	case ${2:+n} in ( n ) return 1 ;; esac ;;
	( 2,isint )	case ${2#"${2%%[!" $CCt$CCn"]*}"} in
			( 0[xX]*[!0123456789abcdefABCDEF]* | [+-]0[xX]*[!0123456789abcdefABCDEF]* )
				return 1 ;;
			( 0[xX]?* | [+-]0[xX]?* )
				;;
			( "" | [+-] | ?*[+-]* | *[!0123456789+-]* | 0*[!01234567]* | [+-]0*[!01234567]* )
				return 1 ;;
			esac ;;
	( 3,id )	case $2 in (  "$3"  ) ;; ( * ) return 1 ;; esac ;;
	( 3,in )	case $2 in ( *"$3"* ) ;; ( * ) return 1 ;; esac ;;
	( 3,left )	case $2 in (  "$3"* ) ;; ( * ) return 1 ;; esac ;;
	( 3,right )	case $2 in ( *"$3"  ) ;; ( * ) return 1 ;; esac ;;
	( 3,match )	'"${_Msh_doMatch}"' ;;
	( 3,ematch )	'"${_Msh_doEMatch}"' ;;
	( 3,lt )	'"${_Msh_doSortsBefore}"' ;;
	( 3,gt )	'"${_Msh_doSortsAfter}"' ;;
	( *,empty | *,isint )
			_Msh_dieArgs "str $1" "$#" "max. 1" ;;
	( *,id )	_Msh_dieArgs "str $1" "$#" "max. 2" ;;
	( *,in | *,left | *,right | *,match | *,ematch )
			_Msh_dieArgs "str $1" "$#" "1 or 2" ;;
	( *,lt | *,gt )	_Msh_dieArgs "str $1" "$#" "2" ;;
	( * )		die "str: invalid operator: $1" ;;
	esac
}'
unset -v _Msh_match_backslash _Msh_doMatchEval _Msh_doMatch _Msh_doEMatch _Msh_doSortsBefore _Msh_doSortsAfter

# --- General file tests. ---
# The can() and is() functions deal correctly with empty removal so are good
# to use with 'use safe' and unquoted variables. They also use substantially
# different and more intuitive logic than 'test', '[' and '[[' do; see README.md.
if thisshellhas DBLBRACKET; then
	# Use [[ if available because it's generally faster and more robust.
	eval '[[ / -nt /dev/null/nonexistent ]]' && _Msh_test= || _Msh_test=y	# for is newer/is older
	eval 'can() {
		case $# in
		( 1 )	case $1 in
			( read | write | exec | traverse )
				# removed empty argument: return false
				return 1 ;;
			( * )	die "can: invalid operator: $1" ;;
			esac ;;
		( 2 )	case $1 in
			( read )
				[[ -r $2 ]] ;;
			( write )
				[[ -d $2 && ( -w $2 && -x $2 ) || -w $2 ]] ;;
			( exec )
				[[ -x $2 && -f $2 ]] ;;
			( traverse )
				[[ -x $2 && -d $2 ]] ;;
			( * )	die "can: invalid operator: $1" ;;
			esac ;;
		( * )	_Msh_dieArgs can "$#" "1 or 2" ;;
		esac
	}
	is() {
		case $# in
		( 1 )	case $1 in
			( present | reg | dir | sym | fifo | socket | blockspecial | charspecial \
			| nonempty | setuid | setgid | mine | mygroup )
				# removed empty argument: return false
				return 1 ;;
			( * )	die "is: invalid operator: $1" ;;
			esac ;;
		( 2 )	case $1 in
			( present )
				[[ -e $2 || -L $2 ]] ;;
			( reg )	[[ ! -L $2 && -f $2 ]] ;;
			( dir )	[[ ! -L $2 && -d $2 ]] ;;
			( sym )	[[ -L $2 ]] ;;
			( fifo )
				[[ ! -L $2 && -p $2 ]] ;;
			( socket )
				[[ ! -L $2 && -S $2 ]] ;;
			( blockspecial )
				[[ ! -L $2 && -b $2 ]] ;;
			( charspecial )
				[[ ! -L $2 && -c $2 ]] ;;
			( nonempty )
				if [[ -d $2 ]]; then
					[[ -r $2 && -x $2 ]] || return 2
					case $- in
					( *f* ) set +f
						set -- "${2%/}" "${2%/}"/[*] "${2%/}"/* "${2%/}"/.[!.]* "${2%/}"/.??*
						set -f ;;
					( * )	set -- "${2%/}" "${2%/}"/[*] "${2%/}"/* "${2%/}"/.[!.]* "${2%/}"/.??* ;;
					esac
					[[ "${#} $2 $3 $4 $5" != "5 $1/[*] $1/* $1/.[!.]* $1/.??*" ]]
				else
					[[ -s $2 ]]
				fi ;;
			( setuid )
				[[ -u $2 ]] ;;
			( setgid )
				[[ -g $2 ]] ;;
			( mine )
				[[ -O $2 ]] ;;
			( mygroup )
				[[ -G $2 ]] ;;
			( onterminal )
				case $2 in
				( *[!0123456789]* )
					die "is onterminal: invalid file descriptor: $2" ;;
				( * )	[[ -t $2 ]] ;;
				esac ;;
			( -L )	case $2 in
				( present | reg | dir | sym | fifo | socket | blockspecial | charspecial )
					# removed empty argument: return false
					return 1 ;;
				( * )	die "is -L: invalid operator: $2" ;;
				esac ;;
			( * )	die "is: invalid operator: $2" ;;
			esac ;;
		( 3 )	case $1 in
			( -L )	case $2 in
				( present )
					[[ -e $3 ]] ;;
				( reg )	[[ -f $3 ]] ;;
				( dir )	[[ -d $3 ]] ;;
				( sym )	[[ -L $3 && -e $3 ]] ;;	# "is -L sym": test if valid symlink.
				( fifo )
					[[ -p $3 ]] ;;
				( socket )
					[[ -S $3 ]] ;;
				( blockspecial )
					[[ -b $3 ]] ;;
				( charspecial )
					[[ -c $3 ]] ;;
				( * )	die "is -L: invalid operator: $2" ;;
				esac ;;
			( newer )
				if [[ -L "$2" || -L "$3" ]]; then
					if is present "$2"; then is present "$3" || return 0; else return 1; fi
					[[ $2 == -* ]] && set -- "$1" "./$2" "$3"
					case $(PATH=$DEFPATH; unset -f find  # QRK_EXECFNBI compat
						exec find "$2" -newer "$3" -print -prune) in
					( "" ) return 1 ;;
					esac
				else
					[[ $2 -nt $3'${_Msh_test:+' || ( -e $2 && ! -e $3 )'}' ]]
				fi ;;
			( older )
				if [[ -L "$2" || -L "$3" ]]; then
					if is present "$3"; then is present "$2" || return 0; else return 1; fi
					[[ $3 == -* ]] && set -- "$1" "$2" "./$3"
					case $(PATH=$DEFPATH; unset -f find  # QRK_EXECFNBI compat
						exec find "$3" -newer "$2" -print -prune) in
					( "" ) return 1 ;;
					esac
				else
					[[ $2 -ot $3'${_Msh_test:+' || ( -e $3 && ! -e $2 )'}' ]]
				fi ;;
			( samefile )
				[[ -L "$2" ]] && set -- "$1" "$2" "$3" "A"
				[[ -L "$3" ]] && set -- "$1" "$2" "$3" "${4-}B"
				case ${4-} in
				( AB )	# Check if two symlinks are hardlinks of each other, which "test A -ef B" does not allow.
					# We use the first field of "ls -i" output, which is the inode.
					push IFS -f
					IFS=$WHITESPACE; set -f
					set -- "$1" "$2" $(PATH=$DEFPATH; unset -f ls; exec ls -idF "$3")  # QRK_EXECFNBI compat
					set -- "$1" "$3" $(PATH=$DEFPATH; unset -f ls; exec ls -idF "$2")  # QRK_EXECFNBI compat
					pop IFS -f
					let "$# > 3" && str isint "$3" && str isint "$2" \
					|| die "is samefile: internal error" || return
					[[ $3 == "$2" ]] ;;
				( "" )	[[ $2 -ef $3 ]] ;;
				( * )	return 1 ;;
				esac ;;
			( onsamefs )
				# Make sure we have path names so we can strip the last element.
				[[ $2 != */* ]] && set -- "$1" "$PWD/$2" "$3"
				[[ $3 != */* ]] && set -- "$1" "$2" "$PWD/$3"
				# Return false if either of the items does not exist.
				[[ -e $2 || -L $2 ]] || return
				[[ -e $3 || -L $3 ]] || return
				# Strip any non-regular, non-directory files from the paths.
				[[ -L $2 || (! -f $2 && ! -d $2) ]] && set -- "$1" "${2%/*}" "$3"
				[[ -L $3 || (! -f $3 && ! -d $3) ]] && set -- "$1" "$2" "${3%/*}"
				# Do the test if the stripped paths are different.
				[[ ${2:-/} == "${3:-/}" ]] || _Msh_doIsOnSameFs "${2:-/}" "${3:-/}" ;;
			( * )	die "is: invalid arguments" ;;
			esac ;;
		( 4 )	case $1 in
			( -L )	case $2 in
				( newer )
					[[ $3 -nt $4'${_Msh_test:+' || ( -e $3 && ! -e $4 )'}' ]] ;;
				( older )
					[[ $3 -ot $4'${_Msh_test:+' || ( -e $4 && ! -e $3 )'}' ]] ;;
				( samefile )
					[[ $3 -ef $4 ]] ;;
				( onsamefs )
					# Make sure we have path names so we can strip the last element.
					[[ $3 != */* ]] && set -- "$1" "$2" "$PWD/$3" "$4"
					[[ $4 != */* ]] && set -- "$1" "$2" "$3" "$PWD/$4"
					# Return false if either of the items does not exist.
					[[ -e $3 || -L $3 ]] || return
					[[ -e $4 || -L $4 ]] || return
					# If we have a valid symlink to a non-regular, non-directory file, substitute the
					# target of the link before stripping its final element to keep "df -P" happy.
					if [[ -L $3 && -e $3 && ! -d $3 && ! -f $3 ]]; then
						set -- "$1" "$2" "$(POSIXLY_CORRECT=y PATH=$DEFPATH command ls -ld -- "$3"
							put X)" "$4" "$3"
						set -- "$1" "$2" "${3%${CCn}X}" "$4" "$5"
						set -- "$1" "$2" "${3#*" $5 -> "}" "$4"
					fi
					if [[ -L $4 && -e $3 && ! -d $4 && ! -f $4 ]]; then
						set -- "$1" "$2" "$3" "$(POSIXLY_CORRECT=y PATH=$DEFPATH command ls -ld -- "$4"
							put X)" "$4"
						set -- "$1" "$2" "$3" "${4%${CCn}X}" "$5"
						set -- "$1" "$2" "$3" "${4#*" $5 -> "}"
					fi
					# Strip any invalid symlinks or non-regular, non-directory files from the paths.
					[[ ! -e $3 || (! -f $3 && ! -d $3) ]] && set -- "$1" "$2" "${3%/*}" "$4"
					[[ ! -e $4 || (! -f $4 && ! -d $4) ]] && set -- "$1" "$2" "$3" "${4%/*}"
					# Do the test if the paths are different.
					[[ ${3:-/} == "${4:-/}" ]] || _Msh_doIsOnSameFs "${3:-/}" "${4:-/}" ;;
				( * )	die "is -L: invalid operator: $3" || return ;;
				esac ;;
			( * )	die "is: invalid arguments" || return ;;
			esac ;;
		( * )	_Msh_dieArgs is "$#" "1 or 2" ;;
		esac
	}'
else
	# Note: 'test' was hardened against failure above using a shell function.
	test / -nt /dev/null/nonexistent && _Msh_test= || _Msh_test=y	# for is newer/is older
	eval 'can() {
		case $# in
		( 1 )	case $1 in
			( read | write | exec | traverse )
				# removed empty argument: return false
				return 1 ;;
			( * )	die "can: invalid operator: $1" ;;
			esac ;;
		( 2 )	case $1 in
			( read )
				test -r "$2" ;;
			( write )
				if	test -d "$2"
				then	test -w "$2" && test -x "$2"
				else	test -w "$2"
				fi ;;
			( exec )
				test -x "$2" && test -f "$2" ;;
			( traverse )
				test -x "$2" && test -d "$2" ;;
			( * )	die "can: invalid operator: $1" || return ;;
			esac ;;
		( * )	_Msh_dieArgs can "$#" "1 or 2" ;;
		esac
	}
	is() {
		case $# in
		( 1 )	case $1 in
			( present | reg | dir | sym | fifo | socket | blockspecial | charspecial \
			| setuid | setgid | mine | mygroup )
				# removed empty argument: return false
				return 1 ;;
			( * )	die "is: invalid operator: $1" || return ;;
			esac ;;
		( 2 )	case $1 in
			( present )
				test -e "$2" || test -L "$2" ;;
			( reg )	! test -L "$2" && test -f "$2" ;;
			( dir )	! test -L "$2" && test -d "$2" ;;
			( sym )	test -L "$2" ;;
			( fifo )
				! test -L "$2" && test -p "$2" ;;
			( socket )
				! test -L "$2" && test -S "$2" ;;
			( blockspecial )
				! test -L "$2" && test -b "$2" ;;
			( charspecial )
				! test -L "$2" && test -c "$2" ;;
			( nonempty )
				if test -d "$2"; then
					test -r "$2" && test -x "$2" || return 2
					case $- in
					( *f* ) set +f
						set -- "${2%/}" "${2%/}"/[*] "${2%/}"/* "${2%/}"/.[!.]* "${2%/}"/.??*
						set -f ;;
					( * )	set -- "${2%/}" "${2%/}"/[*] "${2%/}"/* "${2%/}"/.[!.]* "${2%/}"/.??* ;;
					esac
					case "${#} $2 $3 $4 $5" in
					( "5 $1/[*] $1/* $1/.[!.]* $1/.??*" )
						return 1 ;;
					esac
				else
					test -s "$2"
				fi ;;
			( setuid )
				test -u "$2" ;;
			( setgid )
				test -g "$2" ;;
			# (The -O and -G test/[ operators are technically
			# non-standard, but their support in shells that can
			# run the rest of modernish is universal.)
			( mine )
				test -O "$2" ;;
			( mygroup )
				test -G "$2" ;;
			( onterminal )
				case $2 in
				( *[!0123456789]* )
					die "is onterminal: invalid file descriptor: $2" || return ;;
				( * )	test -t "$2" ;;
				esac ;;
			( -L )	case $2 in
				( present | reg | dir | sym | fifo | socket | blockspecial | charspecial )
					# removed empty argument: return false
					return 1 ;;
				( * )	die "is -L: invalid operator: $2" || return ;;
				esac ;;
			( * )	die "is: invalid operator: $1" || return ;;
			esac ;;
		( 3 )	case $1 in
			( -L )	case $2 in
				( present )
					test -e "$3" ;;
				( reg )	test -f "$3" ;;
				( dir )	test -d "$3" ;;
				( sym )	test -L "$3" && test -e "$3" ;;	# "is -L sym": test if valid symlink.
				( fifo )
					test -p "$3" ;;
				( socket )
					test -S "$3" ;;
				( blockspecial )
					test -b "$3" ;;
				( charspecial )
					test -c "$3" ;;
				( * )	die "is -L: invalid operator: $2" || return ;;
				esac ;;
			# (The -nt, -ot and -ef test/[ operators are
			# technically non-standard, but their support in shells
			# that can run the rest of modernish is universal.)
			( newer )
				if test -L "$2" || test -L "$3"; then
					if is present "$2"; then is present "$3" || return 0; else return 1; fi
					case $2 in ( -* ) set -- "$1" "./$2" "$3";; esac
					case $(PATH=$DEFPATH; unset -f find  # QRK_EXECFNBI compat
						exec find "$2" -newer "$3" -print -prune) in
					( "" ) return 1 ;;
					esac
				else
					test "$2" -nt "$3"'${_Msh_test:+' || { test -e "$2" && ! test -e "$3"; '\}}'
				fi ;;
			( older )
				if test -L "$2" || test -L "$3"; then
					if is present "$3"; then is present "$2" || return 0; else return 1; fi
					case $3 in ( -* ) set -- "$1" "$2" "./$3";; esac
					case $(PATH=$DEFPATH; unset -f find  # QRK_EXECFNBI compat
						exec find "$3" -newer "$2" -print -prune) in
					( "" ) return 1 ;;
					esac
				else
					test "$2" -ot "$3"'${_Msh_test:+' || { test -e "$3" && ! test -e "$2"; '\}}'
				fi ;;
			( samefile )
				test -L "$2" && set -- "$1" "$2" "$3" "A"
				test -L "$3" && set -- "$1" "$2" "$3" "${4-}B"
				case ${4-} in
				( AB )	# Check if two symlinks are hardlinks of each other, which "test A -ef B" does not allow.
					# We use the first field of "ls -i" output, which is the inode.
					push IFS -f
					IFS=$WHITESPACE; set -f
					set -- "$1" "$2" $(PATH=$DEFPATH; unset -f ls; exec ls -idF "$3")  # QRK_EXECFNBI compat
					set -- "$1" "$3" $(PATH=$DEFPATH; unset -f ls; exec ls -idF "$2")  # QRK_EXECFNBI compat
					pop IFS -f
					let "$# > 3" && str isint "$3" && str isint "$2" \
					|| die "is samefile: internal error" || return
					str id "$3" "$2" ;;
				( "" )	test "$2" -ef "$3" ;;
				( * )	return 1 ;;
				esac ;;
			( onsamefs )
				# Make sure we have path names so we can strip the last element.
				case $2 in (*/*) ;; (*) set -- "$1" "$PWD/$2" "$3" ;; esac
				case $3 in (*/*) ;; (*) set -- "$1" "$2" "$PWD/$3" ;; esac
				# Return false if either of the items does not exist.
				test -e "$2" || test -L "$2" || return
				test -e "$3" || test -L "$3" || return
				# Strip any non-regular, non-directory files from the paths.
				{ test -L "$2" || { ! test -f "$2" && ! test -d "$2"; }; } && set -- "$1" "${2%/*}" "$3"
				{ test -L "$3" || { ! test -f "$3" && ! test -d "$3"; }; } && set -- "$1" "$2" "${3%/*}"
				# Do the test if the stripped paths are different.
				case ${2:-/} in ("${3:-/}") ;; ( * ) _Msh_doIsOnSameFs "${2:-/}" "${3:-/}" ;; esac ;;
			( * )	die "is: invalid arguments" || return ;;
			esac ;;
		( 4 )	case $1 in
			( -L )	case $2 in
				( newer )
					test "$3" -nt "$4"'${_Msh_test:+' || { test -e "$3" && ! test -e "$4"; '\}}' ;;
				( older )
					test "$3" -ot "$4"'${_Msh_test:+' || { test -e "$4" && ! test -e "$3"; '\}}' ;;
				( samefile )
					test "$3" -ef "$4" ;;
				( onsamefs )
					# Make sure we have path names so we can strip the last element.
					case $3 in (*/*) ;; (*) set -- "$1" "$2" "$PWD/$3" "$4" ;; esac
					case $4 in (*/*) ;; (*) set -- "$1" "$2" "$3" "$PWD/$4" ;; esac
					# Return false if either of the items does not exist.
					test -e "$3" || test -L "$3" || return
					test -e "$4" || test -L "$4" || return
					# If we have a valid symlink to a non-regular, non-directory file, substitute the
					# target of the link before stripping its final element to keep "df -P" happy.
					if test -L "$3" && test -e "$3" && ! test -d "$3" && ! test -f "$3"; then
						set -- "$1" "$2" "$(POSIXLY_CORRECT=y PATH=$DEFPATH command ls -ld -- "$3"
							put X)" "$4" "$3"
						set -- "$1" "$2" "${3%${CCn}X}" "$4" "$5"
						set -- "$1" "$2" "${3#*" $5 -> "}" "$4"
					fi
					if test -L "$4" && test -e "$3" && ! test -d "$4" && ! test -f "$4"; then
						set -- "$1" "$2" "$3" "$(POSIXLY_CORRECT=y PATH=$DEFPATH command ls -ld -- "$4"
							put X)" "$4"
						set -- "$1" "$2" "$3" "${4%${CCn}X}" "$5"
						set -- "$1" "$2" "$3" "${4#*" $5 -> "}"
					fi
					# Strip any invalid symlinks or non-regular, non-directory files from the paths.
					{ ! test -e "$3"||{ ! test -f "$3"&&! test -d "$3";};} && set -- "$1" "$2" "${3%/*}" "$4"
					{ ! test -e "$4"||{ ! test -f "$4"&&! test -d "$4";};} && set -- "$1" "$2" "$3" "${4%/*}"
					# Do the test if the stripped paths are different.
					case ${3:-/} in ("${4:-/}") ;; ( * ) _Msh_doIsOnSameFs "${3:-/}" "${4:-/}" ;; esac ;;
				( * )	die "is -L: invalid operator: $3" || return ;;
				esac ;;
			( * )	die "is: invalid arguments" || return ;;
			esac ;;
		( * )	_Msh_dieArgs is "$#" "1 or 2" || return ;;
		esac
	}'
fi
_Msh_doIsOnSameFs() {
	# Invoke POSIX "df -P" and isolate the file system names and mount points as reliably as possible.
	# Ref. (thread): https://www.mail-archive.com/austin-group-l@opengroup.org/msg01699.html
	_Msh_is=$(export POSIXLY_CORRECT=y "PATH=$DEFPATH"
		unset -f df sed  # QRK_EXECFNBI compat
		exec df -P -- "$1" "$2" | exec sed '1d; s/\([[:blank:]]\{1,\}[[:digit:]]\{1,\}\)\{4\}%[[:blank:]]\{1,\}/,/')
	# If the two lines are identical, the files are on the same filesystem.
	case ${_Msh_is#*$CCn} in
	( *$CCn* | "${_Msh_is}" )  # >2 lines or 1 line
		die "is onsamefs: internal error" || return ;;
	( "${_Msh_is%$CCn*}" )
		unset -v _Msh_is ;;
	( * )	! unset -v _Msh_is ;;
	esac
}

# -------------

# For thisshellhas(): Now that we have is(), we can replace the preliminary
# _Msh_doCapTest() with a more straightforward and robust one.
_Msh_doCapTest() {
	unset -v _Msh_test						# guarantee unset variable for testing purposes
	set -- "$MSH_PREFIX/libexec/modernish/cap/$1.t"			# this can be used by test scripts as well
	is -L reg "$1" || return 127
	. "$1" 1>&2
}

# -------------

# Initialization, phase 2.

# At this point, all main modernish library functionality was initialised
# successfully, so everything can be used except features based on aliases
# (such as 'not', 'so').

# If shell supports it, then set modernish functions to read-only.
if thisshellhas ROFUNC; then
	readonly -f \
	@ROFUNC@	# install.sh will replace this tag
fi 2>/dev/null

# On zsh with broken POSIX 'readonly', we redefined 'readonly' as an alias for
# 'typeset -rg' near the top. For purposes other than modernish initalisation,
# we can properly fix the bug by making it conditional upon posixbuiltins,
# albeit at the cost of forking a subshell for every 'readonly' invocation.
if isset ZSH_VERSION && alias readonly >/dev/null 2>&1 && thisshellhas DBLBRACKET; then
	alias readonly='typeset -r"$([[ -o posixbuiltins ]] && builtin echo g)"'
fi

# Work around intermittent ksh93 bug (at least on version 93u+ 2012-08-01)
# where multibyte locale settings corrupt the shell-quoting in the output of
# commands like 'export -p' and 'trap'. Triggering a locale re-init fixes it.
if thisshellhas KSH93FUNC; then
	LC_ALL=foo_BAR.baz command true 2>/dev/null  # BUG_CMDSPASGN compat: 'true' is a regular builtin
fi

# Internal function to pre-load the modules 'used' by hashbang comments for
# ksh93 compatibility. This is needed for aliases set in modules to be
# properly expanded on ksh93.
# Only the 'use' command is allowed here (more specific commands may be
# allowed in the future). No shell grammar is parsed: all arguments are
# whitespace-separated with no way of quoting them to include whitespace;
# variables and compound commands won't work; etc. An argument starting with
# '#' causes it and the rest of the line to be ignored. It is considered a
# fatal error for any command to yield an exit status > 0.
_Msh_tmp_doHashbangPreload() {
	# eval all immediately adjacent hashbang lines that contain non-pathname commands
	while IFS='' read -r _Msh_doHbPl_L 2>/dev/null; do
		str left "${_Msh_doHbPl_L}" "#!" || break
		# remove '#!'
		_Msh_doHbPl_L=${_Msh_doHbPl_L#??}
		# isolate command name
		_Msh_doHbPl_a=${_Msh_doHbPl_L#*"${_Msh_doHbPl_L%%[!"$WHITESPACE"]*}"}	# trim left whitespace		"
		_Msh_doHbPl_a=${_Msh_doHbPl_a%%["$WHITESPACE"]*}			# trim right arguments + whitespace
		str in "${_Msh_doHbPl_a}" '/' && continue
		_Msh_doHbPl_C=''
		push IFS -f
		unset -v IFS; set -f  # default field splitting; no globbing
		for _Msh_doHbPl_a in ${_Msh_doHbPl_L}; do
			case ${_Msh_doHbPl_C} in
			( '' )	case ${_Msh_doHbPl_a} in
				# whitelist allowed commands below
				( use ) _Msh_doHbPl_C=${_Msh_doHbPl_a} ;;
				( * )	die "invalid hashbang command: ${_Msh_doHbPl_L}" ;;
				esac ;;
			( * )	# don't allow any shell grammar: shellquote each whitespace-separated argument
				case ${_Msh_doHbPl_a} in
				( \#* )	break ;; # comment
				esac
				shellquote _Msh_doHbPl_a
				_Msh_doHbPl_C=${_Msh_doHbPl_C}\ ${_Msh_doHbPl_a} ;;
			esac
		done
		pop IFS -f
		eval "${_Msh_doHbPl_C}" || die "hashbang command failed: ${_Msh_doHbPl_L}"
	done
	unset -v _Msh_doHbPl_C _Msh_doHbPl_a	# keep last line in _Msh_doHbPl_L
}

# Cleanup.
case ${_Msh_IFS+s} in
( s )	IFS=${_Msh_IFS}; unset -v _Msh_IFS ;;
( * )	unset -v IFS ;;
esac
PATH=${_Msh_PATH}
unset -v _Msh_PATH _Msh_test _Msh_test2 _Msh_ftlcount
unset -f _Msh_testFn _Msh_testFn2 _Msh_initExit _Msh_have

# With init succeeded, time to make these permanent.
#readonly MSH_VERSION MSH_SHELL MSH_PREFIX MSH_CONFIG	# installer will uncomment this

# --------------------
# ------- MAIN -------
# --------------------

# Find out how modernish was invoked and launch the invoking program if necessary.
ME=$0	# temporary identity for possible error messages
if ! str right "$0" '/modernish' && ! str id "$0" 'modernish'; then

	# --- modernish was sourced (simple use) ---
	if isset -i; then
		# interactive shell: be welcoming
		readonly "ME=modernish on ${0#-}"
		putln "Welcome to the modernish age (version $MSH_VERSION)."
		thisshellhas --cache  # use --cache before --show so results aren't cached in a subshell below
		# do a nice sorted and indented output of shell capabilities
		put 'This shell has: '				# length 16
		(PATH=$DEFPATH
			thisshellhas --show |
			sort |
			paste -s -d ' ' - |
			fold -s -w "$(( ${COLUMNS:-80} - 16 ))" |
			sed '2,$ s/^/                /')	# 16 spaces
		use var/stack/trap
		pushtrap 'putln "Exiting modernish $MSH_VERSION. Bye."' EXIT
	else
		# non-interactive shell
		readonly "ME=$0"
		if is -L reg "$ME" && can read "$ME"; then
			_Msh_tmp_doHashbangPreload < "$ME"
			unset -v _Msh_doHbPl_L
		fi
	fi
	unset -f _Msh_tmp_doHashbangPreload
	# Restore 'allexport' option if it was set
	if isset _Msh_allexport; then
		set -a
		unset -v _Msh_allexport
	fi
	# Resume parent program or return to command prompt.
	# We used to 'return' from the dot script here, but yash < 2.44 in interactive mode doesn't like it.
	# Instead, enclose the rest in an extra else ... fi.

else

# --- modernish *is* the shell (cross-platform use, must be portable) ---
# (e.g. '#!/usr/bin/env modernish' or 'modernish -c "commands here"'):

# Provide one consistent modernish version of the notoriously unportable 'echo', so cross-shell
# modernish programs can safely expect the same behaviour. This version does not interpret any control
# characters and supports only one option, '-n', which, like BSD 'echo', suppresses the newline.
# However, unlike BSD 'echo', if '-n' is the only argument, it is not interpreted as an option and the
# string '-n' is printed instead. This makes it safe to output arbitrary data using this version of
# 'echo' as long as it is given as a single argument (using quoting if needed).
# **NOTE**: This is provided for adapting existing scripts. The use of 'put' and 'putln' is preferred
# for new scripts.
echo() {
	case ${#},${1-} in
	( 0, )   putln ;;
	( 1,* )  putln "$1" ;;
	( *,-n ) shift; put "$@" ;;
	( * )	 put "$@$CCn" ;;
	esac
}
if thisshellhas ROFUNC; then
	readonly -f echo
fi

if let "$#"; then
	# parse standard shell options.
	unset -v _Msh_script _Msh_noexec _Msh_xtrace _Msh_stdin
	while str match "${1:-}" '[+-]*'; do
		case $1 in
		( [+-][!-]?* ) # split a set of combined options
			_Msh_opts=${1#?}
			_Msh_plusmin=${1%"$_Msh_opts"}
			shift
			while ! str empty "${_Msh_opts}"; do
				if str match "${_Msh_opts}" "[o]*"; then
				# if the option requires an argument, split it and break out of loop
				# (it is always the last in a combined set)
					_Msh_arg=${_Msh_plusmin}${_Msh_opts%"${_Msh_opts#?}"}
					push _Msh_arg
					_Msh_opts=${_Msh_opts#?}
					if ! str empty "${_Msh_opts}"; then
						_Msh_arg=${_Msh_opts}
						push _Msh_arg
					fi
					break
				fi
				# split options that do not require arguments (and invalid options) until we run out
				_Msh_arg=${_Msh_plusmin}${_Msh_opts%"${_Msh_opts#?}"}
				push _Msh_arg
				_Msh_opts=${_Msh_opts#?}
			done
			while pop _Msh_arg; do
				set -- "${_Msh_arg}" "$@"
			done
			unset -v _Msh_opts _Msh_arg _Msh_plusmin
			continue ;;
		( -c )	_Msh_script= ;;
		( +c )	unset -v _Msh_script ;;
		( -i | -l )
			_Msh_doExit 2 "To use modernish interactively, source it ('. modernish') in your shell profile."
			;;
		( +i | +l ) ;;
		( -s )	_Msh_stdin= ;;
		( +s )	unset -v _Msh_stdin ;;
		( [+-]o )
			let "$# >= 2" || _Msh_doExit 2 "option requires argument: -o"
			case $1,$2 in
			( -o,errexit )
				_Msh_doExit 2 "'$1 $2' not supported; use sys/cmd/harden instead." ;;
			( ?o,noexec )
				_Msh_noexec=${1%o}n ;;
			( ?o,xtrace )
				_Msh_xtrace=${1%o}x ;;
			( * )	set "$1" "$2" || exit ;;
			esac
			shift
			;;
		( -e )	_Msh_doExit 2 "'-e' not supported; use sys/cmd/harden instead."
			;;
		( [+-]n )
			_Msh_noexec=$1 ;;
		( [+-]x )
			_Msh_xtrace=$1 ;;
		( [+-][!-]* )
			set "$1" || exit ;;
		( --use | --use= )
			_Msh_doExit 2 "option requires argument: --use" ;;
		( --use=* )
			# Preload module. Safely field-split the argument to allow for arguments to modules.
			_Msh_tmp_doUse() {
				push IFS -f
				unset -v IFS; set -f
				set -- $1
				pop IFS -f
				use "$@"
			}
			_Msh_tmp_doUse "${1#--use=}"
			unset -f _Msh_tmp_doUse ;;
		( --version )
			putln "$MSH_VERSION"
			exit
			;;
		( --test )
			shift
			testsdir=libexec/modernish/tests
			_Msh_tmp_doHashbangPreload < "$MSH_PREFIX/$testsdir/run.sh" || exit
			unset -f _Msh_tmp_doHashbangPreload
			unset -v _Msh_doHbPl_L
			. "$MSH_PREFIX/$testsdir/run.sh"
			exit
			;;
		( --help )
			putln "This is modernish version $MSH_VERSION."
			(unset -v MSH_VERSION 2>/dev/null) && putln "Not installed. Run install.sh to use a known-good shell." \
			|| putln \
				"Installed within:	MSH_PREFIX=$MSH_PREFIX" \
				"With known-good shell:	MSH_SHELL=$MSH_SHELL" \
				"Default utility PATH:	DEFPATH=$DEFPATH"
			putln "User config directory:	MSH_CONFIG=$MSH_CONFIG"
			PATH=$DEFPATH sed -n '3,$ p' "$MSH_PREFIX/share/doc/modernish/HELP"
			exit ;;
		( -- )
			shift
			break
			;;
		( * )
			_Msh_doExit 2 "invalid option: $1"
			;;
		esac
		shift
	done
fi
if isset _Msh_script; then
	# A script was given with the -c option.
	# Other shells take the first non-option argument as the script and pass the rest on to the PPs for
	# the script, starting with $0; act alike, except we can't set $0 so we'll set $ME instead.
	let "$#" && _Msh_script=$1 && shift || _Msh_doExit 2 'the -c option was specified but no script was given'
	let "$#" && ME=$1 && shift
	readonly ME
	thisshellhas BUG_HDOCMASK && _Msh_umask=$(umask) && umask u+r
	_Msh_tmp_doHashbangPreload <<-EOF
	${_Msh_script}
	EOF
	thisshellhas BUG_HDOCMASK && umask "${_Msh_umask}" && unset -v _Msh_umask
	unset -f _Msh_tmp_doHashbangPreload
	isset _Msh_allexport && set -a && unset -v _Msh_allexport
	eval "unset -v _Msh_script _Msh_doHbPl_L _Msh_noexec _Msh_xtrace" \
		"${_Msh_noexec+${CCn}set ${_Msh_noexec}}" \
		"${_Msh_xtrace+${CCn}set ${_Msh_xtrace}}" \
		"${CCn}${_Msh_script}"
elif let "$#" && ! isset _Msh_stdin; then
	# A script file was given as the first argument.
	is -L reg "$1" || _Msh_doExit 127 "file not found: $1"
	readonly "ME=$1"
	shift
	_Msh_tmp_doHashbangPreload < "$ME"
	unset -f _Msh_tmp_doHashbangPreload
	unset -v _Msh_doHbPl_L
	isset _Msh_allexport && set -a && unset -v _Msh_allexport
	case $ME in	# keep '.' from searching in PATH if no directory was given
	( */* )	isset _Msh_xtrace && eval "unset -v _Msh_xtrace; set ${_Msh_xtrace}"
		. "$ME" ;;
	( * )	isset _Msh_xtrace && eval "unset -v _Msh_xtrace; set ${_Msh_xtrace}"
		. "./$ME" ;;
	esac
elif is onterminal 0 && ! isset _Msh_stdin; then
	# This is where we wish it were possible to switch a non-interactive shell to interactive and go to
	# its command prompt, retaining all the shell functions we just set, but no shell supports this.
	# We could fake a simple interactive shell here using a loop with 'read', but who would use that?
	_Msh_doExit 2 "To use modernish interactively, source it ('. modernish') in your shell profile."
else
	# We're reading a modernish script from standard input; the user did
	# something like 'echo "$scriptcode" | modernish' or 'modernish <<"EOF"'
	readonly ME
	_Msh_tmp_doHashbangPreload
	unset -f _Msh_tmp_doHashbangPreload
	isset _Msh_allexport && set -a && unset -v _Msh_allexport
	eval "unset -v _Msh_doHbPl_L _Msh_noexec _Msh_xtrace" \
		"${_Msh_noexec+${CCn}set ${_Msh_noexec}}" \
		"${_Msh_xtrace+${CCn}set ${_Msh_xtrace}}" \
		"${CCn}${_Msh_doHbPl_L}${CCn}$(PATH=$DEFPATH exec cat)"
fi

fi # if ! str right "$0" '/modernish' && ! str id "$0" 'modernish'
