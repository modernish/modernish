#! /bin/sh
# -*- mode: sh; -*-

# modernish - a cross-platform POSIX shell modernizer library.
# POSIX reference: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/contents.html

# modernish system constants:
#	$MSH_VERSION
#	$MSH_INTERACTIVE
#	$ME
#	$UID
#	$USER
#	$CC?
#	$CC??
#	$CONTROLCHARS
#	$WHITESPACE
#	$ASCIIALNUM
#	$SHELLSAFECHARS
# modernish internal global variables and functions namespace:
#	_Msh_*

# TODO:
# - trawl for ideas and functionality:
#	http://www.etalabs.net/sh_tricks.html
#	http://apenwarr.ca/log/?m=201102#28

# -------------

# Request standards compliance.
[ -n "${ZSH_VERSION+s}" ] && { emulate sh -o POSIX_ARGZERO -o MULTIBYTE || emulate sh; } 2>| /dev/null
[ -n "${YASH_VERSION+s}" ] && set -o posix +o le-promptsp
export POSIXLY_CORRECT=y	# this also sets -o posix on bash and ksh

# As we're setting stuff to read-only, guard against initializing twice. We
# can't use 'exit' because this file is sourced, so use an 'if' that spans
# the entire script, with the corresponding 'fi' all the way at the end.
#	[NOTE: on ksh, calling 'unset' for already-unset variables gives
#	exit status 1, even if they're not read-only, so we can't test on
#	the exit status of 'unset' to determine if a var is read-only.]
unset -v MSH_VERSION 2>| /dev/null || true
if [ -z "${MSH_VERSION+s}" ]; then

# We don't support set -e (errexit) because it is (a) too tedious and
# (b) incompatible with robust shell programming because it makes it
# very hard to distinguish between different non-zero exit statuses.
# Use the provided 'harden' function instead.
set +e

# Turn off 'allexport'. We're setting many read-only variables. Exporting
# all of them by default is not a good idea (even though they won't be
# read-only when inherited that way). Scripts can set this option again
# after initializing modernish, if desired. (The stack functions 'push' and
# 'pop' temporarily turn it off during execution because exporting the stack
# could cause bad things to happen.)
set +a

# -------------

# Initialization, phase 1.

# --- Shell POSIX compliance requirement checks ---
# Block on shell bugs and standard incompatibilities that would break modernish.
#
# NOTE: all the bug blocking tests need to be compatible with all the bugs
# tested for. So, to be compatible with BUG004, the bug blocking tests need
# to use >| and 2>| instead of > and 2>, even when writing to /dev/null.

unset -v _Msh_defect

# The version of modernish.
readonly MSH_VERSION=0.01dev 2>| /dev/null
test "${MSH_VERSION:-}" = 0.01dev || {
	echo "[BUG000] 'readonly' command doesn't support assignment." 1>&2
	_Msh_defect=y
}

# Remove all aliases from the execution environment,
# as some shells set unhelpful default aliases.
# (For example, ksh93 sets
#	alias command="command "
# which defeats the ability of 'command' to bypass aliases).
\unalias -a 2>| /dev/null || {
	echo "[BUG001] No support for 'unalias -a'.${ZSH_VERSION+ (zsh 5.0.8 fixes this)}" 1>&2
	_Msh_defect=y
}

# On some shells (mksh), the POSIX 'type' command is an alias. We just
# killed it, so restore it, to avoid it being either missing or run as an
# external command (where the results w.r.t. what is a builtin don't apply
# to the currrent shell).
# In all the shells I've tested, the 'type' command is exactly equivalent to
# 'command -V' (capital V). However, POSIX standardises 'command -V' in more
# detail than it does 'type', while every possible output of 'command -V'
# also matches the less-detailed definition of 'type'. So having this
# alias may be a good idea in any case.
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/command.html
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/type.html
# (debian's posh does not support aliases, so we need to block on failing this.)
alias type='command -V' 2>| /dev/null || {
	echo "[BUG002] No support for aliases at all." 1>&2
	_Msh_defect=y
}

# Make sure that we have a way to guarantee running a shell builtin.
{	unset -f command
	command -v test \
	&& command -V test \
	&& command test 42 -eq 42
} >| /dev/null 2>&1 || {
	echo "[BUG003] No or broken 'command' builtin." 1>&2
	_Msh_defect=y
}

# Setting 'noclobber' (-C) blocks writing to devices like /dev/null in
# NetBSD /bin/sh. This is incompatible with 'use safe' in modernish, and it
# is against the standard: "Output redirection using the '>' format shall
# fail if the noclobber option is set and the file named by the expansion of
# word exists AND IS A REGULAR FILE."
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_07_02
case "$-" in
( *C* )	echo hi > /dev/null ;;
( * )	set -C; echo hi > /dev/null && set +C || { set +C; false; } ;;
esac 2>| /dev/null || {
	echo "[BUG004] set -C (-o noclobber) blocks writing to devices." 1>&2
	_Msh_defect=y
}

# Test for minimal POSIX shell arith support, i.e. $((6*i)) must be
# supported and not just $((6*$i)). Run test in a subshell because some
# shells exit on 'syntax error', thwarting our error message.
(	i=7
	test "$((6*i))" -eq 42
) 2>| /dev/null || {
	echo "[BUG005] No or broken POSIX shell arithmetics." 1>&2
	_Msh_defect=y
}

# Make sure we can freeze variables as readonly in an unset state.
# Shell bugs/issues:
# * zsh before 5.0.8 is non-compliant here.
# * ksh may return status nonsuccess on 'unset', so don't use &&.
# * ksh93 has a parsing bug: it will erroneously stop script execution on
#	test "${_Msh_ReadOnlyTest+set}" = ""
#   with a "_Msh_ReadOnlyTest: read-only variable" error, indicating the wrong
#   line number. But this ONLY happens if that command is in a subshell! So to
#   avoid locking out ksh93, don't use a subshell (this speeds up our init
#   anyway) and accept that we have a permanent _Msh_ReadOnlyTest unset
#   readonly. TODO: decide if this bug should stop modernish from being loaded.
unset -v _Msh_ReadOnlyTest
readonly _Msh_ReadOnlyTest
test "${_Msh_ReadOnlyTest+set}" = "" || {
	echo "[BUG006] Can't keep unset variables as read-only.${ZSH_VERSION+ (zsh 5.0.8 fixes this)}" 1>&2
	_Msh_defect=y
}

# Test against a 'case' pattern matching bug in zsh: empty bracket expressions
# swallow subsequent shell grammar, producing unexpected results (in the test
# example below, a false positive match, because the two patterns are taken as
# one, with the "|" being taken as part of the bracket expression rather than
# shell grammar separating two bracket expressions). This is particularly bad
# if you want to pass a bracket expression using a variable or parameter, and
# that variable or parameter could be empty. This means the grammar parsing
# depends on the contents of the variable. Producing false matches without any
# indication or error message is an egregious bug, so block on it.
# This is fixed as of zsh 5.0.8, but *only* in POSIX/'emulate sh' mode.
# (Old versions of yash also had this bug.)
case abc in
( ["${_Msh_ReadOnlyTest:-}"] | [!a-z]* )
	echo "[BUG007] Empty [bracket expression] eats shell grammar.${ZSH_VERSION+ (zsh 5.0.8 fixes this)}${YASH_VERSION+ (yash 2.15 fixes this)}" 1>&2
	_Msh_defect=y
esac

# Test for field splitting corruption in yash 2.8 to 2.37: it swallows
# backslashes at the beginning of fields from the second field on. This
# kills 'shellquote'. Also try to check if there are other bugs with
# backslashes or single quotes.
[ -n "${IFS+s}" ] && _Msh_IFS="$IFS" || unset -v _Msh_IFS
IFS=' '
_Msh_testFn() {
	case "$*" in
	( '\on\e tw'\''o th\'\''re\e \'\''fo\u\r' )
		echo "[BUG008] Field splitting eats initial backslashes.${YASH_VERSION+ (yash 2.38 fixes this)}" 1>&2
		_Msh_defect=y ;;
	( '\on\e \tw'\''o \th\'\''re\e \'\''fo\u\r' )
		echo "[BUG008] Field splitting eats first of initial double backslash.${ZSH_VERSION+ (zsh 4.2.7 fixes this)}" 1>&2
		_Msh_defect=y ;;
	( '\on\e \tw'\''o \th\'\''re\e \\'\''fo\u\r' )
		;;	# OK
	( * )	echo "[BUG008] Undiscovered bug with field splitting! Please report. ($*)" 1>&2
		_Msh_defect=y ;;
	esac
}
_Msh_test='\on\e \tw'\''o \th\'\''re\e \\'\''fo\u\r'
_Msh_testFn ${_Msh_test}
unset -f _Msh_testFn
[ -n "${_Msh_IFS+s}" ] && IFS="${_Msh_IFS}" && unset -v _Msh_IFS || unset -v IFS
unset -v _Msh_test _Msh_IFS

# One version of pdksh 5.2.14 (installed on sdf-eu.org as of May 2015) has a
# very obscure bug: it fails to match a list of characters from a variable in
# a bracket pattern, but only if the variable name is exactly 14 characters
# long! (It breaks shellquote() because SHELLSAFECHARS is a 14 char varname.)
_Msh_test_1234=x	# 14 character variable name
case x in
( [${_Msh_test_1234}] ) ;;
( * )	echo "[BUG009] Problem with 14 characters long variable names." 1>&2
	_Msh_defect=y ;;
esac
unset -v _Msh_test_1234

# Incorrect exit status of test -n with single parenthesis values in
# recent-ish versions of zsh. This can make scripts that process arbitrary
# data (e.g. the shellquote function) take the wrong action, so is a
# critical bug. Also, spurious error message with both test -n and test -z.
test -n '(' 2>| /dev/null || {
	echo "[BUG010] 'test'/'[' -n/-z can't test strings '(' or ')'.${ZSH_VERSION+ (zsh 5.0.8 fixes this)}" 1>&2
	_Msh_defect=y
}

# Incorrect arith parsing of $# followed by minus in zsh. The expression
# $#-1 means $# (number of parameters) minus one, but is misparsed as ${#-}1
# -- the length of $- (shell options) concatenated with '1'. (The bug is
# only triggered if there is no space before the -.)
test "$(($#-1+1))" -eq "$#" || {
	echo "[BUG011] Broken parsing of param. subst. in shell arith.${ZSH_VERSION+ (zsh 5.0.8 fixes this)}" 1>&2
	_Msh_defect=y
}


# --- Non-blocking bug tests ---
# These bugs each get a dedicated readonly so scripts can test on them
# and work around them if necessary.
# (They might still block if an unexpected result is found.)

# BUG_UPP (Unset Positional Parameters).
# Test whether we can access $ and $* if set -u is active and there are no
# parameters. When set -u (-o nounset) is active, NetBSD /bin/sh and older
# versions of ksh93 error out on accessing "$@" and "$*" (the collective
# positional parameters), even if that access is implicit in 'for'. This is
# against the standard:
#    "-u: When the shell tries to expand an unset parameter OTHER THAN THE '@'
#    AND '*' SPECIAL PARAMETERS, it shall write a message to standard error and
#    shall not execute the command containing the expansion [...]".
# Reference:
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_25_03
# (under '-u'). Unfortunately, ksh93 with this bug is still too common to
# block on this.
if ( set -u; set --; dummy="$*"; for dummy do :; done; ) 2>| /dev/null; then
	unset _Msh_has_BUG_UPP
else
	_Msh_has_BUG_UPP=y
fi
readonly _Msh_has_BUG_UPP

# BUG_MULTIBYTE: We're running on a locale with a variable-length character
# set (e.g. UTF-8) but the shell does not support multi-byte characters. For
# instance, ${#var} measures length in bytes, not characters. With
# fixed-length one-byte character sets, the bug is irrelevant so we don't
# set the identifier. Current shells with this bug include dash and most
# branches of pdksh.
# Ref.: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_02
# TODO: Make test reliable. Figure out what all the variable-length
#	character sets are and implement tests for all of them.
unset -v _Msh_has_BUG_MULTIBYTE
case "${LC_ALL:-${LC_CTYPE:-${LANG:-}}}" in
( *.UTF-8 )
	_Msh_test='bÃ¨ta' # 4 char, 5 byte UTF-8 string 'beta' with accent grave on 'e'
	case ${#_Msh_test} in
	( 4 )	;;
	( 5 )	_Msh_has_BUG_MULTIBYTE=y ;;
	( * )	echo "[BUG012] Fatal error in measuring UTF-8 string length. (${#_Msh_test})" 1>&2
		_Msh_defect=y ;;
	esac
	unset -v _Msh_test
	;;
esac
readonly _Msh_has_BUG_MULTIBYTE

# BUG_FNSUBSH: Function definitions within subshells (including command
# substitutions) are ignored if a function by the same name exists in
# the main shell, so the wrong function is executed.
# ksh93 (all current versions as of June 2015) has this bug.
# (This means setlocal...endlocal cannot be used in subshells if
# the script is to be compatible with ksh93. If you use setlocal..endlocal
# in a subshell, including a command substitution, then test if the
# variable _Msh_has_BUG_FNSUBSH is set and refuse to run if it is.)
_Msh_testFn() { echo f1; }
if [ "$( _Msh_testFn() { echo f2; }; _Msh_testFn )" != "f2" ]; then
	_Msh_has_BUG_FNSUBSH=y
else
	unset -v _Msh_has_BUG_FNSUBSH
fi
readonly _Msh_has_BUG_FNSUBSH

# BUG_EVALRET: shell doesn't return from a function if the "return"
# is within an 'eval', but only from the 'eval'. (yash 2.37)
_Msh_testFn() { true; eval "return $?"; return 1; }
if ! _Msh_testFn; then
	_Msh_has_BUG_EVALRET=y
else
	unset -v _Msh_has_BUG_EVALRET
fi
readonly _Msh_has_BUG_EVALRET

# BUG_READWHSP: 'read' does not trim initial IFS whitespace. (yash 2.37)
# (in here-document: four leading spaces and four trailing spaces)
IFS=' ' read _Msh_test <<EOF
    hi    
EOF
case "${_Msh_test}" in
( '    hi' )
	_Msh_has_BUG_READWHSP=y ;;
( 'hi' )
	unset -v _Msh_has_BUG_READWHSP ;;
( * )
	printf '%s\n' "[BUG013] Undiscovered IFS whitespace bug with 'read'." 1>&2
	_Msh_defect=y ;;
esac
unset -v _Msh_test
readonly _Msh_has_BUG_READWHSP

# --- End of bug tests. ---
if [ -n "${_Msh_defect+s}" ]; then
	echo "Sorry, this shell can't run modernish." 1>&2
	exit 127
fi


# --- Shell feature and bug workaround tests ---
# TODO? make these internal vars for a shellfeature() function 

# FULLARITH
# Test for complete POSIX shell arithmetics: assignment, comparison and
# conditional expressions. (This is mandated by POSIX, but as of 2015, too
# many shells don't yet support this to block on it.)
(	i=7
	j=0
	test "$(( (j=6*i)==42 ? 12 : 13 ))" -eq 12 && test "$j" -eq 42
) 2> /dev/null && _Msh_has_FULLARITH=y || unset -v _Msh_has_FULLARITH
readonly _Msh_has_FULLARITH

# PIPEWOSUBSH (pipe without subshell)
# Test if this shell can pipe into a shell command without launching a
# subshell, so that variables survive the pipe construct.
# Known shells with this feature: zsh and ksh93 (not pdksh or mksh).
echo hi | read _Msh_test
if [ "${_Msh_test-}" = hi ]; then
	_Msh_has_PIPEWOSUBSH=y
	unset -v _Msh_test
else
	unset _Msh_has_PIPEWOSUBSH
fi
readonly _Msh_has_PIPEWOSUBSH

# --- Test for optional, non-standard, but common features. ---

# Seed the $RANDOM pseudorandom number generator if we have it, otherwise
# reserve the variable name to prevent incompatible use. Test against the
# seed four times to make the chance of a false negative infinitesimal.
RANDOM="$$"
if [ "$RANDOM" -eq "$$" ] && [ "$RANDOM" -eq "$$" ] && [ "$RANDOM" -eq "$$" ] && [ "$RANDOM" -eq "$$" ]
then
	unset -v RANDOM _Msh_has_RANDOM
	readonly RANDOM
else
	_Msh_has_RANDOM=y
fi
readonly _Msh_has_RANDOM

# Test if we have $LINENO (current shell script line number).
# If not, reserve the name.
# TODO: test if any shell we want to support has a problem with
#	making LINENO readonly even if it's supported.
if [ -n "${LINENO+s}" ]; then
	_Msh_L1="$LINENO"
	_Msh_L2="$LINENO"
	if [ "${_Msh_L1}" = "${_Msh_L2}" ]; then
		unset -v LINENO
	fi
	unset -v _Msh_L1 _Msh_L2
fi
if [ -n "${LINENO+s}" ]; then
	_Msh_has_LINENO=y
else
	readonly LINENO
fi
readonly _Msh_has_LINENO

# Test if we can do function-local variables.
# (The extra 'command' check is to defeat ahead-parsing of aliases
# already killed with 'unalias -a' above.)
if _Msh_fn() { command -v local && local _Msh_X || return; _Msh_X=7; } \
&& _Msh_X=42 && _Msh_fn && [ "${_Msh_X}" -eq 42 ]; then
	_Msh_has_LOCAL=y
elif _Msh_fn() { command -v typeset && typeset _Msh_X || return; _Msh_X=7; } \
&& _Msh_X=42 && _Msh_fn && [ "${_Msh_X}" -eq 42 ]; then
	# alias it on pdksh/mksh (and yash, if not in posix mode)
	alias local=typeset
	_Msh_has_LOCAL=y
else
	unset -v _Msh_has_LOCAL
fi >/dev/null 2>&1
readonly _Msh_has_LOCAL
unset -f _Msh_fn
unset -v _Msh_X


# --- Self-knowledge ---

# Temporary identity.
ME="$(command -v modernish)" || {
	printf "modernish: can't find myself; please add my dir to PATH\n" 1>&2
	exit 127
}

# Bash has the read-only variable $UID, as well as $USER which is not
# read-only. Give them to other shells too, and make both of them read-only.
test "${UID+set}" = 'set' || UID="$(id -u)" || exit 127
test "${USER+set}" = 'set' || USER="$(id -un)" || exit 127
readonly UID USER
# for extra paranoia (also tests we have a functioning mktemp):
#_Msh_tmp="$(mktemp '/tmp/_Msh_id_XXXXXX')" || exit 127
#if test -z "$(find ${_Msh_tmp} -type f -user $UID -user $USER)"; then
#	printf "cannot confirm that my user is really $USER ($UID)\n"
#	exit 127
#fi
#rm -f "${_Msh_tmp}" || exit 127
#unset -v _Msh_tmp

# --- Control character constants ---

# POSIX does not have a good way to refer to control characters in variable
# assignments or as parameters to arbitrary commands. Let's make this
# convenient using readonly variables (constants) in the CC[01][0-9A-F] and
# CC[a-z] namespaces (CC = control character).
#
# We cannot have $CC00 because shell variables can't contain the 0 character.
#
# CC0A (newline) needs to be initialized separately because it is always a
# separator for 'read'. MAKE SURE THE FOLLOWING IS A LITERAL NEWLINE AND
# NOTHING ELSE.
CC0A='
'
# The initialization method below is optimized for speed; the
# straightforward way to do it would be --
#	readonly CC01="$(printf '\1')"
#	readonly CC02="$(printf '\2')"
#	...
#	readonly CC1F="$(printf '\37')"
# but launching a subshell 30 times would noticeably slow down initialization.
# The method below reads from a here-document filled using one subshell.
IFS=',' read CC01 CC02 CC03 CC04 CC05 CC06 CC07 \
	CC08 CC09      CC0B CC0C CC0D CC0E CC0F \
	CC10 CC11 CC12 CC13 CC14 CC15 CC16 CC17 \
	CC18 CC19 CC1A CC1B CC1C CC1D CC1E CC1F <<endofCC || exit
$(printf '\1,\2,\3,\4,\5,\6,\7,\10,\11,\13,\14,\15,\16,\17,\20,\21,\22,\23,\24,\25,\26,\27,\30,\31,\32,\33,\34,\35,\36,\37')
endofCC

# Make them constants.
readonly     CC01 CC02 CC03 CC04 CC05 CC06 CC07 \
	CC08 CC09 CC0A CC0B CC0C CC0D CC0E CC0F \
	CC10 CC11 CC12 CC13 CC14 CC15 CC16 CC17 \
	CC18 CC19 CC1A CC1B CC1C CC1D CC1E CC1F

# For convenience, provide some synonyms corresponding with 'printf' codes:
# e = escape; a = bell (alarm); b = backspace; f = form-feed; n = new-line;
# r = carriage return; t = tab; v = vertical tab
readonly CCe="$CC1B" CCa="$CC07" CCb="$CC08" CCf="$CC0C" CCn="$CC0A" CCr="$CC0D" CCt="$CC09" CCv="$CC0B"

# And these are handy to use in a glob pattern to check against control characters in a string:
#	if match "$var" "*[$CONTROLCHARS]*"; then
#		print "\$var contains at least one control character"
#	fi
# ...or for field splitting:
#	IFS="$WHITESPACE,/"  # split fields at any whitespace, comma or slash, with space a primary separator
readonly CONTROLCHARS="$CC01$CC02$CC03$CC04$CC05$CC06$CC07$CC08$CC09$CC0A$CC0B$CC0C$CC0D$CC0E$CC0F$CC10$CC11$CC12$CC13$CC14$CC15$CC16$CC17$CC18$CC19$CC1A$CC1B$CC1C$CC1D$CC1E$CC1F"
readonly WHITESPACE=" $CCt$CCn$CCv$CCf$CCr"		# starts with a space
readonly ASCIIALNUM=0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
readonly SHELLSAFECHARS="${ASCIIALNUM}.,/:%+=_-"	# safelist for shell-quoting

# -------------

# Internal functions. Subject to change without notice.

_Msh_dieArgs() {
	die "$1: incorrect number of arguments (was $2, must be $3)"
}

# -------------

# Test if argument is valid variable name.

isvarname() {
	[ $# -eq 1 ] || _Msh_dieArgs isvarname "$#" 1 || return
	case "$1" in
	( '' | [0123456789]* | *[!${ASCIIALNUM}_]* )
		false ;;
	esac
}

# -------------

# Test if all of the given words are shell keywords, regular or special
# built in commands, or (for words that are in all caps) optional
# capabilities or bugs that modernish found in the current shell.
# Pure POSIX does not allow for a reliable way to find out what is a shell
# keyword or built in command, but it's essential for feature testing, so
# we have to make do.
# Usage: thisshellhas <word> [ <word> ... ]
# TODO: consider ways of making this more robust.
if ( set +o posix ) 2>/dev/null; then
	# At least one shell (yash) disables a regular built in (such as printf) if the
	# external equivalent is not in $PATH. In that case, this function won't find it.
	# So yash needs a version that disables the POSIX shell option for the lookup.
	thisshellhas() {
		[ "$#" -ge 1 ] || _Msh_dieArgs thisshellhas "$#" 'at least 1' || return
		while [ "$#" -gt 0 ]; do
			case "$1" in
			( *[!ABCDEFGHIJKLMNOPQRSTUVWXYZ_]* )
				(	set +o posix
					unalias "$1"
					unset -f "$1"
					PATH=/dev/null
					command -v "$1"
				) || return 1
				;;
			( * )
				eval "[ -n \"\${_Msh_has_${1}+s}\" ]" || return
				;;
			esac
			shift
		done >/dev/null 2>&1
	}
else
	# As far as I know, this version works on all other shells.
	thisshellhas() {
		[ "$#" -ge 1 ] || _Msh_dieArgs thisshellhas "$#" 'at least 1' || return
		while [ "$#" -gt 0 ]; do
			case "$1" in
			( *[!ABCDEFGHIJKLMNOPQRSTUVWXYZ_]* )
				(	unalias "$1"
					unset -f "$1"
					PATH=/dev/null
					command -v "$1"
				) || return
				;;
			( * )
				eval "[ -n \"\${_Msh_has_${1}+s}\" ]" || return
				;;
			esac
			shift
		done >/dev/null 2>&1
	}
fi

isvarname() {
	case "$1" in
	( '' | [0123456789]* | *[!${ASCIIALNUM}_]* )
		false ;;
	esac
}

# -------------

# unexport: the opposite of export
# Usage: like 'export'.
# Unset the 'export' bit of a variable, conserving its value, or assign
# variables without the export bit even if 'set -a' (allexport) is active.

unexport() {
	[ "$#" -ge 1 ] || _Msh_dieArgs unexport "$#" 'at least 1' || return
	case "$-" in
	( *a* )
		set +a
		unexport "$@"
		eval "set -a; return $?"
		return	# BUG_EVALRET workaround
		;;
	esac
	for _Msh_nE_V do
		isvarname "${_Msh_nE_V%%=*}" || die "unexport: invalid variable name: ${_Msh_nE_V}" || return
		case "${_Msh_nE_V}" in
		( *=* )
			unset -v "${_Msh_nE_V%%=*}"
			_Msh_nE_val="${_Msh_nE_V#*=}"
			eval "${_Msh_nE_V%%=*}=\"\${_Msh_nE_val}\""
			;;
		( * )
			if eval "[ -n \"\${${_Msh_nE_V}+s}\" ]"; then
				eval "_Msh_nE_val=\"\${${_Msh_nE_V}}\""
				unset -v "${_Msh_nE_V}"
				eval "${_Msh_nE_V}=\"\${_Msh_nE_val}\""
			fi
			;;
		esac
	done
	unset -v _Msh_nE_V _Msh_nE_val
}

# -------------

# Stack functions.
# Every variable has its own stack: simply do push VAR and pop VAR.
# Also works for saving/restoring shell options, e.g.: push -f; pop -f
# Uses global variable namespace: _Msh__V*__S*
#
# Features:
#	- Saves and restores not just value, but set/unset state.
#	- Stack size is limited by memory or shell constraints only.
#	- Fast: does not launch any subshell or external process.
#	- Cleans up after itself: leaves no trace in the environment upon
#         empty stack.
#
# Use cases:
#	- Easily store lots of arbitary data to use later.
#	- Code blocks (not just functions) with 'fake' local variables.
#	- Easy temporary field splitting ('push IFS' and 'pop IFS' work fine).
#
# TODO:	Don't export stack variables even if 'allexport' is active;
#	unset and restore the -a shell option.

if thisshellhas FULLARITH; then
# Version of push() and pop() for shells with FULLARITH.

	# Push each variable's value or shell option setting on its respective stack.
	# Usage: push <item> [ <item> ...]
	#	where <item> is a variable name or shell option (dash plus letter).
	push() {
		[ "$#" -ge 1 ] || _Msh_dieArgs push "$#" 'at least 1' || return

		# Exporting the stack would be bad; run 'push' without 'set -a' active.
		case "$-" in
		( *a* )
			set +a
			push "$@"
			eval "set -a; return $?"
			return	# BUG_EVALRET workaround
			;;
		esac

		# Validate variable names before doing anything. Shell varname
		# constraints apply; also disallow internal separators __V and __S.
		for _Msh_push_V do
			case "${_Msh_push_V}" in
			( -[abcdefghijklmnpqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ] ) ;;	# short-form shell option: ok
			( '' | [0123456789]* | *[!${ASCIIALNUM}_]* | *__[VS]* )
				die "push: invalid variable name or shell option: ${_Msh_push_V}" || return ;;
			esac
		done

		for _Msh_push_V do
			# If it's a (short, single) shell option, translate to internal variable.
			case "${_Msh_push_V}" in
			( -? )
				_Msh_push_V="${_Msh_push_V#-}"
				case "$-" in
				( *${_Msh_push_V}* )
					eval "_Msh_ShellOpt_${_Msh_push_V}=''" ;;
				( * )
					unset -v "_Msh_ShellOpt_${_Msh_push_V}" ;;
				esac
				_Msh_push_V="_Msh_ShellOpt_${_Msh_push_V}"
			esac

			# Initialize/validate stack pointer.
			eval "_Msh_push_SP=\"\${_Msh__V${_Msh_push_V}__SP=0}\""
			case "$_Msh_push_SP" in
			( '' | *[!0123456789]* ) die "push: Stack pointer for ${_Msh_push_V} corrupted" || return  ;;
			esac

			# Store value or unset status.
			if eval "[ -n \"\${${_Msh_push_V}+s}\" ]"; then
				eval "_Msh__V${_Msh_push_V}__S${_Msh_push_SP}=\"\$${_Msh_push_V}\""
			else
				unset -v "_Msh__V${_Msh_push_V}__S${_Msh_push_SP}"
			fi

			# Increase stack pointer for next item on stack.
			: $((_Msh__V${_Msh_push_V}__SP = _Msh_push_SP + 1))
		done
		unset -v _Msh_push_V _Msh_push_SP
	}

	# Pop each variable's last value off the stack and restore it into the
	# variable.
	#
	# Returns unsuccessfully without changing anything if *any* of the stacks
	# for the specified variables or shell options is empty. Either all get
	# popped, or none. This helps provide validation against stack inconsistency
	# for groups of variables that should be pushed/popped together.
	#
	# Usage: pop <item> [ <item> ...]
	#	where <item> is a variable name or shell option (dash plus letter).
	pop() {
		[ "$#" -ge 1 ] || _Msh_dieArgs pop "$#" 'at least 1' || return

		# Exporting the stack would be bad; run 'pop' without 'set -a' active.
		case "$-" in
		( *a* )
			set +a
			pop "$@"
			eval "set -a; return $?"
			return	# BUG_EVALRET workaround
			;;
		esac

		# Validate everything before doing anything.
		for _Msh_pop_V do
			case "$_Msh_pop_V" in
			( -[abcdefghijklmnpqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ] )
				_Msh_pop_V="_Msh_ShellOpt_${_Msh_pop_V#-}" ;;
			( '' | [0123456789]* | *[!${ASCIIALNUM}_]* | *__[VS]* )
				die "pop: invalid variable name or shell option: $_Msh_pop_V" || return  ;;
			esac

			# Stack empty?
			eval "[ -n \"\${_Msh__V${_Msh_pop_V}__SP+s}\" ]" || return 1

			eval "_Msh_pop_SP=\"\${_Msh__V${_Msh_pop_V}__SP}\""
			case "${_Msh_pop_SP}" in
			( '' | 0* | *[!0123456789]* ) die "pop: Stack pointer for ${_Msh_pop_V} corrupted" || return  ;;
			esac
		done

		# Do the job.
		for _Msh_pop_V do
			# If shell option, translate to internal variable.
			case "${_Msh_pop_V}" in
			( -? )
				_Msh_pop_V="_Msh_ShellOpt_${_Msh_pop_V#-}" ;;
			esac

			# Decrease stack pointer so it points to the item to pop.
			: $(( _Msh_pop_SP = ( _Msh__V${_Msh_pop_V}__SP = _Msh__V${_Msh_pop_V}__SP - 1 ) ))

			# Restore value or unset status.
			if eval "[ -n \"\${_Msh__V${_Msh_pop_V}__S${_Msh_pop_SP}+s}\" ]"; then
				eval "${_Msh_pop_V}=\"\$_Msh__V${_Msh_pop_V}__S${_Msh_pop_SP}\""
			else
				unset -v "${_Msh_pop_V}"
			fi

			# Clean up: unset the stack variable we just popped off the stack.
			unset -v "_Msh__V${_Msh_pop_V}__S${_Msh_pop_SP}"

			# Clean up: if the stack is empty, unset the stack pointer.
			if [ "${_Msh_pop_SP}" -eq 0 ]; then
				unset -v "_Msh__V${_Msh_pop_V}__SP"
			fi

			# If it's a shell option variable, restore the shell option.
			case "${_Msh_pop_V}" in
			( _Msh_ShellOpt_[abcdefghijklmnpqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ] )
				if eval "[ -n \"\${${_Msh_pop_V}+s}\" ]"; then
					set "-${_Msh_pop_V#_Msh_ShellOpt_}"
					unset -v "${_Msh_pop_V}"
				else
					case "$-" in
					( *${_Msh_pop_V#_Msh_ShellOpt_}* )
						set "+${_Msh_pop_V#_Msh_ShellOpt_}"
						;;
					esac
				fi
				;;
			esac
		done
		unset -v _Msh_pop_V _Msh_pop_SP
	}

else
# Version of push() and pop() for shells without FULLARITH.
	# Push each variable's value or shell option setting on its respective stack.
	# Usage: push <item> [ <item> ...]
	#	where <item> is a variable name or shell option (dash plus letter).
	push() {
		[ "$#" -ge 1 ] || _Msh_dieArgs push "$#" 'at least 1' || return

		# Exporting the stack would be bad; run 'push' without 'set -a' active.
		case "$-" in
		( *a* )
			set +a
			push "$@"
			eval "set -a; return $?"
			return	# BUG_EVALRET workaround
			;;
		esac

		# Validate variable names before doing anything. Shell varname
		# constraints apply; also disallow internal separators __V and __S.
		for _Msh_push_V do
			case "${_Msh_push_V}" in
			( -[abcdefghijklmnpqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ] ) ;;	# short-form shell option: ok
			( '' | [0123456789]* | *[!${ASCIIALNUM}_]* | *__[VS]* )
				die "push: invalid variable name or shell option: ${_Msh_push_V}" || return ;;
			esac
		done

		for _Msh_push_V do
			# If it's a (short, single) shell option, translate to internal variable.
			case "${_Msh_push_V}" in
			( -? )
				_Msh_push_V="${_Msh_push_V#-}"
				case "$-" in
				( *${_Msh_push_V}* )
					eval "_Msh_ShellOpt_${_Msh_push_V}=''" ;;
				( * )
					unset -v "_Msh_ShellOpt_${_Msh_push_V}" ;;
				esac
				_Msh_push_V="_Msh_ShellOpt_${_Msh_push_V}"
			esac

			# Initialize/validate stack pointer.
			eval "_Msh_push_SP=\"\${_Msh__V${_Msh_push_V}__SP=0}\""
			case "$_Msh_push_SP" in
			( '' | *[!0123456789]* ) die "push: Stack pointer for ${_Msh_push_V} corrupted" || return  ;;
			esac

			# Store value or unset status.
			if eval "[ -n \"\${${_Msh_push_V}+s}\" ]"; then
				eval "_Msh__V${_Msh_push_V}__S${_Msh_push_SP}=\"\$${_Msh_push_V}\""
			else
				unset -v "_Msh__V${_Msh_push_V}__S${_Msh_push_SP}"
			fi

			# Increase stack pointer for next item on stack.
			eval "_Msh__V${_Msh_push_V}__SP=$((_Msh_push_SP + 1))"
		done
		unset -v _Msh_push_V _Msh_push_SP
	}

	# Pop each variable's last value off the stack and restore it into the
	# variable.
	#
	# Returns unsuccessfully without changing anything if *any* of the stacks
	# for the specified variables or shell options is empty. Either all get
	# popped, or none. This helps provide validation against stack inconsistency
	# for groups of variables that should be pushed/popped together.
	#
	# Usage: pop <item> [ <item> ...]
	#	where <item> is a variable name or shell option (dash plus letter).
	pop() {
		[ "$#" -ge 1 ] || _Msh_dieArgs pop "$#" 'at least 1' || return

		# Exporting the stack would be bad; run 'pop' without 'set -a' active.
		case "$-" in
		( *a* )
			set +a
			pop "$@"
			eval "set -a; return $?"
			return	# BUG_EVALRET workaround
			;;
		esac

		# Validate everything before doing anything.
		for _Msh_pop_V do
			case "$_Msh_pop_V" in
			( -[abcdefghijklmnpqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ] )
				_Msh_pop_V="_Msh_ShellOpt_${_Msh_pop_V#-}" ;;
			( '' | [0123456789]* | *[!${ASCIIALNUM}_]* | *__[VS]* )
				die "pop: invalid variable name or shell option: $_Msh_pop_V" || return  ;;
			esac

			# Stack empty?
			eval "[ -n \"\${_Msh__V${_Msh_pop_V}__SP+s}\" ]" || return 1

			eval "_Msh_pop_SP=\"\${_Msh__V${_Msh_pop_V}__SP}\""
			case "${_Msh_pop_SP}" in
			( '' | 0* | *[!0123456789]* ) die "pop: Stack pointer for ${_Msh_pop_V} corrupted" || return  ;;
			esac
		done

		# Do the job.
		for _Msh_pop_V do
			# If shell option, translate to internal variable.
			case "${_Msh_pop_V}" in
			( -? )
				_Msh_pop_V="_Msh_ShellOpt_${_Msh_pop_V#-}" ;;
			esac

			# Decrease stack pointer so it points to the item to pop.
			eval "_Msh__V${_Msh_pop_V}__SP=\$((_Msh__V${_Msh_pop_V}__SP - 1))"
			eval "_Msh_pop_SP=\"\${_Msh__V${_Msh_pop_V}__SP}\""

			# Restore value or unset status.
			if eval "[ -n \"\${_Msh__V${_Msh_pop_V}__S${_Msh_pop_SP}+s}\" ]"; then
				eval "${_Msh_pop_V}=\"\$_Msh__V${_Msh_pop_V}__S${_Msh_pop_SP}\""
			else
				unset -v "${_Msh_pop_V}"
			fi

			# Clean up: unset the stack variable we just popped off the stack.
			unset -v "_Msh__V${_Msh_pop_V}__S${_Msh_pop_SP}"

			# Clean up: if the stack is empty, unset the stack pointer.
			if [ "${_Msh_pop_SP}" -eq 0 ]; then
				unset -v "_Msh__V${_Msh_pop_V}__SP"
			fi

			# If it's a shell option variable, restore the shell option.
			case "${_Msh_pop_V}" in
			( _Msh_ShellOpt_[abcdefghijklmnpqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ] )
				if eval "[ -n \"\${${_Msh_pop_V}+s}\" ]"; then
					set "-${_Msh_pop_V#_Msh_ShellOpt_}"
					unset -v "${_Msh_pop_V}"
				else
					case "$-" in
					( *${_Msh_pop_V#_Msh_ShellOpt_}* )
						set "+${_Msh_pop_V#_Msh_ShellOpt_}"
						;;
					esac
				fi
				;;
			esac
		done
		unset -v _Msh_pop_V _Msh_pop_SP
	}

fi

# Check if there is anything left on a variable or shell options's stack.
# Returns 0 (true) if the stack is empty, 1 (false) if not.
stackempty() {
	[ "$#" -eq 1 ] || _Msh_dieArgs stackempty "$#" 1 || return
	case "$1" in
	( -[abcdefghijklmnpqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ] )
		set -- "_Msh_ShellOpt_${1#-}" ;;
	esac
	case "$1" in
	( '' | [0123456789]* | *[!${ASCIIALNUM}_]* | *__[VS]* )
		die "stackempty: invalid variable name or shell option: $1" || return ;;
	esac
	eval "[ -z \"\${_Msh__V${1}__SP+s}\" ]"
}

# Outputs the size of a variable's stack.
stacksize() {
	[ "$#" -eq 1 ] || _Msh_dieArgs stacksize "$#" 1 || return
	case "$1" in
	( -[abcdefghijklmnpqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ] )
		set -- "_Msh_ShellOpt_${1#-}" ;;
	esac
	case "$1" in
	( '' | [0123456789]* | *[!${ASCIIALNUM}_]* | *__[VS]* )
		die "stacksize: invalid variable name or shell option: $1" || return ;;
	esac
	eval "printf '%s\n' \${_Msh__V${1}__SP:-0}"
}

# Outputs the contents of a variable's stack, top down, with items
# separated by <separator> (defaults to linefeed), and ending in a linefeed.
# Shell options NOT supported. (TODO? support them; reconcile with options)
# Usage: printstack [ -Q ] <varname> [ <separator> ]
# Option -Q shell-quotes each stack value output.
# The separator can be any number of arbitrary characters.
# TODO: Options for bottom-up output; prefixing SP on each line; make separator an option
printstack() {
	_Msh_printstack_optQ=''
	case "$1" in
	( -Q )	_Msh_printstack_optQ=yes; shift ;;
	( -* )	die "printstack: invalid option: $1" || return ;;
	esac
	[ "$#" -eq 1 ] || [ "$#" -eq 2 ] || _Msh_dieArgs printstack "$#" '1 or 2 (excl. option -Q)' || return
	case "$1" in
	( '' | [0123456789]* | *[!${ASCIIALNUM}_]* | *__[VS]* )
		die "printstack: invalid variable name: $1" || return ;;
	esac

	# Return non-success if stack empty.
	if eval "[ -z \"\${_Msh__V${1}__SP+s}\" ]"; then
		unset -v _Msh_printstack_optQ
		return 1
	fi

	# Validate stack pointer.
	eval "_Msh_printstack_i=\"\${_Msh__V${1}__SP}\""
	case "$_Msh_printstack_i" in
	( '' | *[!0123456789]* ) die "printstack: Stack pointer for $1 corrupted" || return ;;
	esac

	# Output the stack.
	while [ "${_Msh_printstack_i}" -gt 0 ]; do
		_Msh_printstack_i="$((_Msh_printstack_i-1))"
		if eval "[ -n \"\${_Msh__V${1}__S${_Msh_printstack_i}+s}\" ]"; then
			eval "_Msh_printstack_VAL=\"\${_Msh__V${1}__S${_Msh_printstack_i}}\""
			[ -z "${_Msh_printstack_optQ}" ] || shellquote _Msh_printstack_VAL
			printf '%s' "${_Msh_printstack_VAL}"
		else
			# TODO: do this better
			printf '%s' "*** UNSET ***"
		fi
		[ "${_Msh_printstack_i}" -gt 0 ] && printf '%s' "${2:-$CCn}" || printf '\n'
	done

	unset -v _Msh_printstack_i _Msh_printstack_opt _Msh_printstack_optQ _Msh_printstack_VAL
}

# Empties one or more variables' or shell options' stacks.
# Usage: clearstack <item> [ <item> ... ]
# Empties *nothing* if one of the specified items' stack is already empty.
# This allows extra validation when treating several items as a group.
clearstack() {
	[ "$#" -ge 1 ] || _Msh_dieArgs clearstack "$#" 'at least 1' || return

	# Validate everything before doing anything
	for _Msh_clearstack_V do
		case "${_Msh_clearstack_V}" in
		( -[abcdefghijklmnpqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ] )
			_Msh_clearstack_V="_Msh_ShellOpt_${_Msh_clearstack_V#-}" ;;
		esac
		case "$_Msh_clearstack_V" in
		( '' | [0123456789]* | *[!${ASCIIALNUM}_]* | *__[VS]* )
			die "clearstack: invalid variable name or shell option: $_Msh_clearstack_V" || return ;;
		esac

		# if the stack for one of the given items is empty, don't clear any of them
		eval "[ -n \"\${_Msh__V${_Msh_clearstack_V}__SP+s}\" ]" || return

                eval "_Msh_clearstack_SP=\${_Msh__V${_Msh_clearstack_V}__SP}"
		case "${_Msh_clearstack_SP}" in
		( '' | *[!0123456789]* ) die "clearstack: Stack pointer for ${_Msh_clearstack_V} corrupted" || return ;;
		esac
	done

	# Do the job
	for _Msh_clearstack_V do
		case "${_Msh_clearstack_V}" in
		( -? )
			_Msh_clearstack_V="_Msh_ShellOpt_${_Msh_clearstack_V#-}" ;;
		esac
		eval "_Msh_clearstack_SP=\${_Msh__V${_Msh_clearstack_V}__SP}"
		while [ "${_Msh_clearstack_SP}" -gt 0 ]; do
			_Msh_clearstack_SP="$((_Msh_clearstack_SP - 1))"
			unset -v "_Msh__V${_Msh_clearstack_V}__S${_Msh_clearstack_SP}"
		done
		unset -v "_Msh__V${_Msh_clearstack_V}__SP"
	done
	unset -v _Msh_clearstack_V _Msh_clearstack_SP
}

# -------------

# Shell-quote the values of one or more variables to prepare them for
# safe use with "eval" or other parsing by the shell. If a value only
# contains shell-safe characters, it leaves it unquoted. Empty values
# are quoted.
#
# Usage: shellquote [ -f|+f ] <varname> [ [ -f|+f ] <varname> ... ]
#
# If the -f option is encountered, it always quotes the values of the
# variables coming after the option, even if it only contains shell-safe
# characters. This can be useful for quoting for other contexts, such as
# producing string literals for glob patterns or regular expressions.
# The form +f turns this off again for subsequent variables.
#
# Returns success (0) if all variables were processed successfully, and
# non-success (1) if any undefined (unset) variables were encountered. Unset
# variables are left alone. It continues even after encountering an unset
# variable.
#
# Inspired by "Rich's sh (POSIX shell) tricks":
# http://www.etalabs.net/sh_tricks.html
# under "Shell-quoting arbitrary strings":
# quote () { printf %s\\n "$1" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/'/" ; }
# Rich uses a command substitution with "sed" for this, launching two
# processes for each value to quote. The "shellquote" function does the same
# thing, but in-place. As it doesn't launch any subshells or external
# processes, it's more than 10 times faster (on bash, only 5-ish times).
#
# TODO?
# - option for reading stdin, producing quoted output?
# - option for quoting values rather than variables?
# - option for output to stdout instead of setting variable?
shellquote() {
	[ "$#" -ge 1 ] || _Msh_dieArgs quote "$#" 'at least 1' || return

	# save and set internal field separator
	if [ -n "${IFS+s}" ]; then
		_Msh_qV_IFS="$IFS"
	else
		unset -v _Msh_qV_IFS
	fi
	IFS="'"

	# save globbing state; turn off globbing
	case "$-" in
	( *f* )	_Msh_qV_glob='' ;;
	( * )	set -f; _Msh_qV_glob='set +f;' ;;
	esac

	_Msh_qV_ERR=0
	_Msh_qV_f=''
	for _Msh_qV_N do
		case "${_Msh_qV_N}" in
		( -f )	_Msh_qV_f=y; continue ;;
		( +f )	_Msh_qV_f=''; continue ;;
		( '' | [0123456789]* | *[!${ASCIIALNUM}_]* )
			# if 'die' doesn't kill the program, then restore IFS/globbing before returning
			die "shellquote: invalid option or variable name: ${_Msh_qV_N}" || { _Msh_qV_ERR="$?"; break; } ;;
		esac
		
		if eval "[ -z \"\${${_Msh_qV_N}+s}\" ]"
		then
			_Msh_qV_ERR=1
			continue
		fi

		eval "_Msh_qV_VAL=\"\${${_Msh_qV_N}}\""

		if [ "${#_Msh_qV_VAL}" -eq 0 ]
		then
			# Quote empties.
			_Msh_qV_VAL="''"
#		elif [ "${#_Msh_qV_VAL}" -gt 16384 ]
#		then
#			# The number and size grows exponentially with quoting levels; doing parameter substitution on
#			# big variables with 1000s of quotes can lock up the shell, so fall back to 'sed' if excessive.
#			# However, this quoting algorithm is more primitive, so the growth exponent is higher.
#			_Msh_qV_VAL="$(printf '%s\n' "${_Msh_qV_VAL}" | sed "s/'/'\\\\''/g; 1 s/^/'/; \$ s/\$/'/")"
		elif ! case "${_Msh_qV_VAL}" in
			# If it's safe to double-quote without escaping anything, do so. (A mixed quoting
			# strategy slightly mitigates exponential growth with multiple quoting levels.)
			# Ref.: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_02_03
			( *[\"\$\`\\]* )
				false
				;;
			( *[!"${SHELLSAFECHARS}"]* )
				_Msh_qV_VAL="\"${_Msh_qV_VAL}\""
				;;
			# Shell-safe chars only: only quote if -f was given.
			( * )
				if [ -n "${_Msh_qV_f}" ]; then
					_Msh_qV_VAL="'${_Msh_qV_VAL}'"
				fi
				;;
			esac
		then
			# If it's not safe for unescaped double-quoting or not quoting, then
			# use a mixture of single-quoting and backslash-escaping to mitigate
			# exponential growth with multiple levels of quoting.
			# Ref.: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_02_02

			# Split the value of the specified variable at its single quote characters (if
			# any), storing the parts into the positional parameters. Add a protector character
			# 'X' at the end so a final literal single quote is counted.
			set -- ${_Msh_qV_VAL}X

			# First part: backslash-escape any existing initial quotes; add the initial quote.
			_Msh_qV_VAL=''
			while [ "$#" -gt 0 ] && [ -z "${1}" ]; do
				_Msh_qV_VAL="${_Msh_qV_VAL}\\'"
				shift
			done
			_Msh_qV_VAL="${_Msh_qV_VAL}'${1}"
			shift

			# Second to last parts: escape existing single quotes.
			while [ "$#" -gt 0 ]; do
				# Add closing quote.
				_Msh_qV_VAL="${_Msh_qV_VAL}'"
				# Backslash-escape any existing intermediary quotes.
				while [ "$#" -gt 0 ] && [ -z "${1}" ]; do
					_Msh_qV_VAL="${_Msh_qV_VAL}\\'"
					shift
				done
				# Add the escaped single quote plus an opening quote before the next part.
				_Msh_qV_VAL="${_Msh_qV_VAL}\\''${1}"
				shift
			done

			# Remove the protector character. Either prevent a final pair
			# of empty single quotes, or add the final single quote.
			case "${_Msh_qV_VAL}" in
			( *\'X )	_Msh_qV_VAL="${_Msh_qV_VAL%\'X}" ;;
			( *X )		_Msh_qV_VAL="${_Msh_qV_VAL%X}'" ;;
			( * )		die "shellquote: internal error" || _Msh_qV_ERR="$?" ;;
			esac
		fi

		# Replace the value of the specified variable with its quoted value.
		eval "${_Msh_qV_N}=\"\${_Msh_qV_VAL}\""
	done

	if [ -n "${_Msh_qV_IFS+s}" ]; then
		IFS="${_Msh_qV_IFS}"
		unset -v _Msh_qV_IFS
	else
		unset -v IFS
	fi
	eval "unset -v _Msh_qV_VAL _Msh_qV_N _Msh_qV_glob _Msh_qV_ERR _Msh_qV_f;
		${_Msh_qV_glob}
		return ${_Msh_qV_ERR}"
}

# Shell-quote all the positional parameters in-place.
# Usage: shellquoteparams (no arguments)
# (The { } block in the alias is to make it impossible for any excess
# arguments to leak into the positional parameters.)
alias shellquoteparams='{ [ "$#" -eq 0 ] || eval "set -- $(_Msh_doShellQuoteParams "$@")"; }'
_Msh_doShellQuoteParams() {
	for _Msh_qV_p do
		shellquote _Msh_qV_p || die "shellquoteparams: first shellquote failed" || return
		shellquote _Msh_qV_p || die "shellquoteparams: second shellquote failed" || return
		printf '%s ' "${_Msh_qV_p}"
	done
}

# Shell-quote and store (a subrange of) the current positional parameters
# into a variable. To restore them later, it is safe to do:
#	eval "set -- $varname"
# (with double quotes and non-escaped $).
# Usage: storeparams [ -f <firstparam> ] [ -t <lastparam> ] <varname>
#	 (f = from, t = to)
alias storeparams='_Msh_doStoreParams "$#" "${@:-}"'
_Msh_doStoreParams() {
	if [ "$1" -eq 0 ]; then
		# BUG_UPP compatibility: remove empty arg
		shift 2
		if [ "$#" -gt 0 ]; then
			set -- 0 "$@"
		else
			set -- 0
		fi
	fi
	_Msh_sP_f=1
	_Msh_sP_t="$1"
	_Msh_sP_i="$(( $1 + 2 ))"
	while [ "$#" -ge "${_Msh_sP_i}" ] \
		&& eval "[ \"X\${${_Msh_sP_i}#-}\" != \"X\${${_Msh_sP_i}}\" ]" \
		&& eval "_Msh_sP_o=\"\${${_Msh_sP_i}#-}\""
	do
		case "${_Msh_sP_o}" in
		( - )	break ;;
		( f )	_Msh_sP_i="$((_Msh_sP_i+1))"
			[ "$#" -ge "${_Msh_sP_i}" ] || die "storeparams: -f: option requies an argument" || return
			eval "_Msh_sP_f=\"\${${_Msh_sP_i}}\"" ;;
		( f* )	_Msh_sP_f="${_Msh_sP_o#f}" ;;
		( t )	_Msh_sP_i="$((_Msh_sP_i+1))"
			[ "$#" -ge "${_Msh_sP_i}" ] || die "storeparams: -t: option requies an argument" || return
			eval "_Msh_sP_t=\"\${${_Msh_sP_i}}\"" ;;
		( t* )	_Msh_sP_t="${_Msh_sP_o#t}" ;;
		esac
		_Msh_sP_i="$((_Msh_sP_i+1))"
	done
	[ "$#" -ge "${_Msh_sP_i}" ] || die "storeparams: variable name expected" || return
	eval "_Msh_sP_V=\"\${${_Msh_sP_i}}\""
	isvarname "${_Msh_sP_V}" || die "storeparams: invalid variable name: ${_Msh_sP_V}" || return
	isint "${_Msh_sP_f}" && [ "${_Msh_sP_f}" -ge 1 ] || die "storeparams: -f: invalid value: '${_Msh_sP_f}'" || return
	isint "${_Msh_sP_t}" || die "storeparams: -t: invalid value: '${_Msh_sP_t}'" || return
	[ "${_Msh_sP_t}" -gt "$#" ] && _Msh_sP_t="$#"
	_Msh_sP_PPs=''
	shift "${_Msh_sP_f}"
	_Msh_sP_i="${_Msh_sP_f}"
	while [ "${_Msh_sP_i}" -le "${_Msh_sP_t}" ]; do
		_Msh_sP_P="$1"
		shellquote _Msh_sP_P || die "storeparams: 'shellquote' failed" || return
		_Msh_sP_PPs="${_Msh_sP_PPs:+${_Msh_sP_PPs} }${_Msh_sP_P}"
		_Msh_sP_i=$((_Msh_sP_i+1))
		shift
	done
	eval "${_Msh_sP_V}=\"\${_Msh_sP_PPs}\""
	unset -v _Msh_sP_f _Msh_sP_t _Msh_sP_o _Msh_sP_V _Msh_sP_i _Msh_sP_P _Msh_sP_PPs
}

# ----------------

# Adds a trap to each specified signal's trap stack
# Usage: pushtrap <command> <sigspec> [ <sigspec> ... ]
# TODO: Idea: add 'key' option to protect against popping by others.
pushtrap() {
	[ "$#" -ge 2 ] || _Msh_dieArgs pop "$#" 'at least 2' || return
	_Msh_pushtrapCMD="$1"
	shellquote _Msh_pushtrapCMD
	shift
	for _Msh_pushtrap_sig do
		case "${_Msh_pushtrap_sig}" in
		( 1 )	_Msh_pushtrap_sig='HUP' ;;
		( 2 )	_Msh_pushtrap_sig='INT' ;;
		( 3 )	_Msh_pushtrap_sig='QUIT' ;;
		( 6 )	_Msh_pushtrap_sig='ABRT' ;;
		( 9 )	_Msh_pushtrap_sig='KILL' ;;
		( 14 )	_Msh_pushtrap_sig='ALRM' ;;
		( 15 )	_Msh_pushtrap_sig='TERM' ;;
		esac
		case "${_Msh_pushtrap_sig#SIG}" in
		( '' | [0123456789]* | *[!${ASCIIALNUM}]* )
			die "pushtrap: invalid signal specification: ${_Msh_pushtrap_sig}" || return ;;
		esac
		eval "_Msh_trap${_Msh_pushtrap_sig#SIG}=${_Msh_pushtrapCMD}"
		push "_Msh_trap${_Msh_pushtrap_sig#SIG}"
		command trap "_Msh_doTraps ${_Msh_pushtrap_sig#SIG}" "${_Msh_pushtrap_sig#SIG}" \
			|| die "pushtrap: 'trap' failed" || return
		unset -v "_Msh_trap${_Msh_pushtrap_sig#SIG}"
	done
	unset -v _Msh_pushtrapCMD _Msh_pushtrap_sig
}

# Removes a trap from each signal's trap stack without executing it.
# Clear the signal's master trap if there are no more left on the stack.
# Use: poptrap <sigspec> [ <sigspec> ... ]
poptrap() {
	for _Msh_poptrap_sig do
		_Msh_poptrap_sig="${_Msh_poptrap_sig#SIG}"
		case "${_Msh_poptrap_sig}" in
		( '' | [0123456789]* | *[!${ASCIIALNUM}]* )
			die "poptrap: invalid signal specification: ${_Msh_poptrap_sig}" || return ;;
		esac
		pop "_Msh_trap${_Msh_poptrap_sig}" || return
		unset -v "_Msh_trap${_Msh_poptrap_sig}"
		if stackempty "_Msh_trap${_Msh_poptrap_sig}"; then
			command trap - "${_Msh_poptrap_sig}"
		fi
	done
	unset -v _Msh_poptrap_sig
}

# Do the traps for a signal. Start from the top of the stack, but don't pop
# the commands, as not all signals lead to termination and some may be
# trapped repeatedly. (Internal function. Subject to change without notice.)
_Msh_doTraps() {
	eval "[ \"\${_Msh__V_Msh_trap${1}__SP+set}\" = 'set' ]" || return
	eval "_Msh_doTraps_i=\${_Msh__V_Msh_trap${1}__SP}"
	while [ "${_Msh_doTraps_i}" -gt 0 ]; do
		_Msh_doTraps_i="$((_Msh_doTraps_i-1))"
		eval "eval \"\${_Msh__V_Msh_trap${1}__S${_Msh_doTraps_i}}\""
	done
	unset -v _Msh_doTraps_i
}

# Alias the builtin 'trap' to a replacement to discourage overwriting other
# traps on the same signal. (Overriding 'trap' with a function doesn't work
# on every shell; an alias is more reliable.)
alias trap='_Msh_newTrap'
# TODO: make a functioning trap command here that will use the trap stack
# non-destructively according to POSIX and/or existing implementations .
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#trap
_Msh_newTrap() {
	die "Use pushtrap and poptrap instead of trap.${CCn}Replacement 'trap' command not yet implemented."
}

# Save the current positional parameters on the stack.
if ! thisshellhas BUG_UPP; then
	alias pushparams='{ _Msh_doPushParams "$@"; }'
	_Msh_doPushParams() {
		unset -v _Msh_PPs
		while [ "$#" -gt 0 ]; do
			_Msh_pushparams_P="$1"
			shellquote _Msh_pushparams_P || die "pushparams: 'shellquote' failed" || return
			_Msh_PPs="${_Msh_PPs+${_Msh_PPs} }${_Msh_pushparams_P}"
			shift
		done
		push _Msh_PPs || die "pushparams: 'push' failed" || return
		unset -v _Msh_PPs _Msh_pushparams_P
	}
else
	# Version for compatibility with BUG_UPP
	alias pushparams='{ _Msh_doPushParams "$#" "${@:-}"; }'
	_Msh_doPushParams() {
		[ "$1" -eq 0 ] && shift 2 || shift
		unset -v _Msh_PPs
		while [ "$#" -gt 0 ]; do
			_Msh_pushparams_P="$1"
			shellquote _Msh_pushparams_P || die "pushparams: 'shellquote' failed" || return
			_Msh_PPs="${_Msh_PPs+${_Msh_PPs} }${_Msh_pushparams_P}"
			shift
		done
		push _Msh_PPs || die "pushparams: 'push' failed" || return
		unset -v _Msh_PPs _Msh_pushparams_P
	}
fi

# Restore the last-pushed positional parameters. Returns successfully if
# there were positional parameters to restore, unsuccessfully if not.
alias popparams='{ pop _Msh_PPs && eval "set -- $_Msh_PPs" && unset -v _Msh_PPs; }'

# -------------

# TODO:
#float()
# arbitrary precision floating point arithmetic using pure shell

# -------------

# Function that installs a function to harden non-function commands by
# testing their exit status against values indicating error or system
# failure. This is modernish's superior replacement for 'set -e' (errexit).
#
# What this exit status should be depends on the command. For standard
# commands, refer to the POSIX standard. For others, see their manual pages.
#
# You can't harden a shell function this way because the hardening function
# itself would replace it.
#
# Usage: harden [ as <commandname/path> ] <funcname> <testexpr>
# Usage example: harden grep 'gt 1': grep fails on exit status > 1
# The command must have a name valid for a shell function.
#
# Unfortunately it can only work for commands that have valid function names.
# Thankfully the set of commands that don't have valid function names is small.
harden() {
	if [ "X${1-}" = "Xas" ]; then
		[ "$#" -eq 4 ] && _Msh_harden_cmd="$2" && _Msh_harden_func="$3" && shift 2
	else
		[ "$#" -eq 2 ] && _Msh_harden_cmd="$1" && _Msh_harden_func="$1"
	fi || die "harden: incorrect arguments${CCn}" \
		"usage: harden <cmdname> <testexpr>${CCn}" \
		"       harden as <cmdname/path> <funcname> <testexpr>" || return

	case "${_Msh_harden_func}" in
	( '' | [0123456789]* | *[!${ASCIIALNUM}_]* )
		die "harden: invalid shell function name: ${_Msh_harden_func}" || return
		;;
	( 'command' | 'set' | 'return' | 'case' | 'do' | 'done' | 'elif' | 'else' \
	| 'esac' | 'fi' | 'for' | 'if' | 'in' | 'then' | 'until' | 'while' )
		die "harden: can't harden '${_Msh_harden_func}'" || return
		;;
	esac

	_Msh_harden_cmd="$(command -v "${_Msh_harden_cmd}")"
	case "${_Msh_harden_cmd}" in
	( */"$1" )
		# Got external command. Shell-quote it for 'eval' in case of weird path name.
		shellquote _Msh_harden_cmd
		;;
	( "alias $1="* )
		die "harden: can't harden an alias: $1" || return
		;;
	( "$1" )
		thisshellhas "$1" || die "harden: can't harden a shell function: $1" || return
		# Got shell built-in command.
		_Msh_harden_cmd="command $1"
		;;
	( '' )
		die "harden: command not found: '$1'" || return
		;;
	( * )
		die "harden: failure: unexpected result '$1' from 'command -v \"$1\"'" || return
		;;
	esac

	# Evaluate the status check expression, translating it to shell commands.
	_Msh_harden_arg="$2"
	_Msh_harden_expr=''
	_Msh_harden_Plvl=0
	push IFS && IFS="$WHITESPACE" && set -- $2 && pop IFS || die "harden: internal error" || return
	while [ "$#" -gt 0 ]; do
		case "$1" in
		( '(' )	_Msh_harden_expr="${_Msh_harden_expr} {"
			_Msh_harden_Plvl="$((_Msh_harden_Plvl+1))"
			;;
		( ')' )	_Msh_harden_expr="${_Msh_harden_expr}; }"
			_Msh_harden_Plvl="$((_Msh_harden_Plvl-1))"
			;;
		( eq | ne | lt | le | gt | ge )
			[ "$#" -gt 1 ] || die "harden: unexpected end of status expression: ${_Msh_harden_arg}" || return
			( : "$(($2))" ) || die \
				"harden: invalid arithmetic expression '$2' in status expression: ${_Msh_harden_arg}" || return
			_Msh_harden_s="$(($2))"
			[ "${_Msh_harden_s}" -ge 0 ] && [ "${_Msh_harden_s}" -le 255 ] \
			&& _Msh_harden_expr="${_Msh_harden_expr} [ \"\$1\" -$1 ${_Msh_harden_s} ]" \
			&& shift
			;;
		( * )	false
			;;
		esac || die "harden: invalid error status expression: ${_Msh_harden_arg}" || return
		shift
		if [ "$#" -gt 0 ]; then
			case "$1" in
			( '(' | ')' )
				continue
				;;
			( '&&' | '||' )
				_Msh_harden_expr="${_Msh_harden_expr} $1"
				shift
				[ "$#" -gt 0 ] && [ "$1" != ')' ] || die \
					"harden: unexpected end of status expression: ${_Msh_harden_arg}" || return
				;;
			( '*' )	die "harden: syntax error in status expression: ${_Msh_harden_arg}" || return
				;;
			esac
		fi
	done
	[ "${_Msh_harden_Plvl}" -eq 0 ] || die "harden: unbalanced parentheses: ${_Msh_harden_arg}" || return
	set -- 0
	eval "${_Msh_harden_expr}"
	case "$?" in
	( 1 ) ;;
	( 0 ) die "harden: success means failure in status expression: ${_Msh_harden_arg}" || return ;;
	( * ) die "harden: invalid error status expression: ${_Msh_harden_arg}" || return ;;
	esac

	# Just to make sure:
	{ unalias 'command' 'set' 'return'; unset -f 'command' 'set' 'return'; } 2> /dev/null

	# Set the hardening function.
	# (As an exception, there is no '|| return' after 'die', because if we're in
	# an interactive shell that can't be killed, we want the command to exit with
	# its own status code, not that of 'die'.)
	if ! thisshellhas BUG_UPP; then
		eval "${_Msh_harden_func}() {
			${_Msh_harden_cmd} \"\$@\" && return
			set -- \"\$?\" ':' ${_Msh_harden_cmd} \"\$@\"
			if${_Msh_harden_expr}; then
				shellquoteparams
				die \"${_Msh_harden_func}: command failed with status \$@\"
			fi
			return \"\$1\"
		}"
	else
		# Version for compatibility with BUG_UPP
		eval "${_Msh_harden_func}() {
			if [ \"\$#\" -eq 0 ]; then
				${_Msh_harden_cmd} && return
				set -- \"\$?\" ':' ${_Msh_harden_cmd}
			else
				${_Msh_harden_cmd} \"\$@\" && return
				set -- \"\$?\" ':' ${_Msh_harden_cmd} \"\$@\"
			fi
			if${_Msh_harden_expr}; then
				shellquoteparams
				die \"${_Msh_harden_func}: command failed with status \$@\"
			fi
			return \"\$1\"
		}"
	fi

	unset -v _Msh_harden_cmd _Msh_harden_func _Msh_harden_expr _Msh_harden_Plvl _Msh_harden_s _Msh_harden_arg
}

# -------------

# POSIX: "It is not possible to use echo portably across all POSIX systems
# unless both -n (as the first argument) and escape sequences are omitted."
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/echo.html#tag_20_37_16
#
# Here is the modernish version of 'echo', so at least all modernish
# programs can safely expect the same behaviour. This version does not
# interpret any control characters and supports only one option, '-n',
# which, like BSD 'echo', suppresses the newline. However, unlike BSD
# 'echo', if '-n' is the only argument, it is not interpreted as an option
# and the string is printed instead. This makes it safe to output arbitrary
# data using this version of 'echo' as long as only one argument is given to
# each invocation.
#

if ! thisshellhas BUG_UPP; then
	echo() {
		[ -n "${IFS+s}" ] && _Msh_echo_IFS="$IFS" || unset -v _Msh_echo_IFS
		IFS=' '	# separator for "$*"
		if [ "$#" -ge 2 ] && [ "X$1" = 'X-n' ]; then
			shift
			printf '%s' "$*"
		else
			printf '%s\n' "$*"
		fi
		[ -n "${_Msh_echo_IFS+s}" ] && IFS="${_Msh_echo_IFS}" && unset -v _Msh_echo_IFS || unset -v IFS
	}
else
	# BUG_UPP compatible version.
	echo() {
		[ -n "${IFS+s}" ] && _Msh_echo_IFS="$IFS" || unset -v _Msh_echo_IFS
		IFS=' '	# separator for "$*"
		if [ "$#" -ge 2 ] && [ "X$1" = 'X-n' ]; then
			shift
			printf '%s' "$*"
		elif [ "$#" -ge 1 ]; then
			printf '%s\n' "$*"
		else
			printf '\n'
		fi
		[ -n "${_Msh_echo_IFS+s}" ] && IFS="${_Msh_echo_IFS}" && unset -v _Msh_echo_IFS || unset -v IFS
	}
fi

# Extended 'exit'. Usage: exit [ -u ] [ <status> [ <message> ] ]
# (Be sure to still respect/restore IFS, etc. as exit traps may be executed after this!)
alias exit=_Msh_doExit
_Msh_doExit() {
	_Msh_exit_status="$?"
	if [ "X${1-}" = 'X-u' ]; then
		_Msh_exit_usage=y
		shift
	else
		unset -v _Msh_exit_usage
	fi
	if [ "$#" -ge 1 ]; then
		if ! { case "$1" in ( *[!0123456789]* ) false ;; esac && [ "${#1}" -le 3 ] && [ "$1" -le 255 ]; }
		then
			die "exit: bad exit status: $1" || _Msh_exit_status="$?"
		else
			_Msh_exit_status="$1"
		fi
		shift
	fi
	if [ "$#" -gt 0 ]; then
		echo "${ME##*/}: $@"
	fi
	if [ -n "${_Msh_exit_usage+s}" ]; then
		showusage
	fi
	\command exit "${_Msh_exit_status}"
}

# Default showusage(). Feel free to override with another one.
showusage() {
	printf 'Type %s --help for help.\n' "${ME##*/}" 1>&2
}

# Terminate the program on error, even from subshells.
# For interactive shells, merely return. Hence the need for "|| return".
# Usage: die [ <message> ] || return
die() {
	_Msh_die_usage=''
	if [ "$#" -gt 0 ]; then
		(
			IFS=' '	# separator for "$*"
			printf '%s: %s\n' "${ME##*/}" "$*" 1>&2
		)
	fi
	if [ "${MSH_INTERACTIVE+set}" = 'set' ]; then
		return 143
	else
		# TODO? use SIGKILL instead?
		kill -s TERM -- "-$$" 2>/dev/null	# send SIGTERM to main process and its children
		printf '%s\n' 'die: Warning: SIGTERM was ignored!' 1>&2
		command exit 143
	fi
}

# Use a modernish module.
# If the module is already loaded, does nothing and exits successfully (status 0),
# preventing dependency loops.
# Global internal variable namespace: _Msh_using_*
use() {
	[ "$#" -ge 1 ] || _Msh_dieArgs use "$#" 'at least 1' || return

	# since we're using the module name as part of a variable name, we
	# must validate the input to avoid a code injection vulnerability
	case "$1" in
	( '' | *[!${ASCIIALNUM}/]* )
		die "use: invalid module name: $1" || return ;;
	esac

	_Msh_use_M="$1"
	shift

	# convert slashes to underscores for variable name
	# TODO: convert without subshell
	_Msh_use_V=_Msh_using$( IFS='/'; printf '_%s' ${_Msh_use_M} )

	eval "[ -z \"\${${_Msh_use_V}+s}\" ]" || return 0
	test -r "$_Msh_ModulesDir/$_Msh_use_M.mm" || die "use: module $_Msh_use_M not found" || return

	. "$_Msh_ModulesDir/$_Msh_use_M.mm" || die "use: initialization of module '${_Msh_use_M}' failed" || return

	eval "$_Msh_use_V=y"
	readonly "$_Msh_use_V"
	unset -v _Msh_use_M _Msh_use_V
}

# -------------

# Implementation of 'let' as in ksh, bash and zsh.
# Requires full POSIX arith support.
# NOTE: the prefix and postfix "++" and "--" operators are NOT required by
# POSIX and not portable. For example, instead of 'let X++', use 'let X=X+1'.
# See: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_04
# Shells exit on arith evaluation error, so the usual "|| die" is ineffective.
# TODO: consider making this a module, as it's conditional on full artih.
if thisshellhas FULLARITH; then
	# FreeBSD /bin/sh has a 'let' builtin that only takes one expression (and outputs the result
	# to standard output), so test if we have a version that works as expected.
	if ! thisshellhas let || ! { let _Msh_X=1 _Msh_Y=_Msh_X+3 && [ "${_Msh_X-}" = 1 ] && [ "${_Msh_Y-}" = 4 ]; }
	then
		let() {
			[ "$#" -ge 1 ] || _Msh_dieArgs let "$#" 'at least 1' || return
			while [ "$#" -gt 1 ]; do
				: "$(($1))"
				shift
			done
			return "$((!($1)))"
		}
	fi 2>/dev/null
	unset -v _Msh_X _Msh_Y
fi

# -------------

# Check if a variable is set, a.k.a. declared
# (which is different from it being empty).
# Usage: isset <varname>
isset() {
	[ "$#" -eq 1 ] || _Msh_dieArgs isset "$#" 1 || return
	case "$1" in
	( '' | [0123456789]* | *[!${ASCIIALNUM}_]* )
		die "isset: invalid variable name: $1" || return ;;
	esac
	eval "[ -n \"\${$1+s}\" ]" && return
	[ "$?" -gt 1 ] && die "isset: eval failed"
}

# -------------

# Simple integer arith shortcuts: inc/dec/mult/div/mod <varname> [ <expr> ]
# Increase/decrease/multiply/divide/modulus the value of the variable by the
# result of the integer arithmetic expression <expr>. Default for <expr> is
# 1 for 'inc' and 'dec', 2 for 'mult' and 'div', 256 for 'mod'.
# NOTE: to be portable, until all current shells support full POSIX arith,
#	don't use arith assignments, comparisons or conditionals.
# TODO: figure out sensible default for 'mod'.
if thisshellhas FULLARITH; then
	# High performance variants for shells with full POSIX arith
	# support. The arith operator itself does sufficient validation,
	# though error messages are not always very clear. Shells exit on
	# error, so the usual "|| die" is ineffective.
	inc()  { : "$((${1?inc: needs 1 or 2 arguments}=$1+(${2-1})${3+\\[ inc: excess arguments ]}))"; }
	dec()  { : "$((${1?dec: needs 1 or 2 arguments}=$1-(${2-1})${3+\\[ dec: excess arguments ]}))"; }
	mult() { : "$((${1?mult: needs 1 or 2 arguments}=$1*(${2-2})${3+\\[ mult: excess arguments ]}))"; }
	div()  { : "$((${1?div: needs 1 or 2 arguments}=$1/(${2-2})${3+\\[ div: excess arguments ]}))"; }
	mod()  { : "$((${1?mod: needs 1 or 2 arguments}=$1%(${2-256})${3+\\[ mod: excess arguments ]}))"; }
else
	# Variants for shells with incomplete POSIX arith support.
	# We must use 'eval', so prior validation is necessary.
	alias inc='_Msh_arith inc + 1'
	alias dec='_Msh_arith dec - 1'
	alias mult='_Msh_arith mult \* 2'
	alias div='_Msh_arith div / 2'
	alias mod='_Msh_arith mod % 256'
	_Msh_arith() {
		[ "$#" -ge 4 ] && [ "$#" -le 5 ] || _Msh_dieArgs "$1" "$(($#-3))" '1 or 2' || return
		isvarname "$4" || die "$1: invalid variable name: ${4:-(none)}" || return
		eval "$4=\$(($4$2(${5-$3})))" || die "$1: arith failed" || return
	}
fi

# -------------

# Hardened replacement functions for 'test'/'[', which is hereby deprecated
# for legibility and security reasons.
#
# TODO: writeup re 'test' security, e.g. variable injection "-o 1 -eq 1";
# generally too many syntax pitfalls) Ref.:
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/test.html


# --- Integer number arithmetic tests. ---

# These have the sames name as their 'test'/'[' option equivalents. Unlike
# with 'test', the arguments are shell integer arith expressions, which can
# be anything from simple numbers to complex expressions. As with $(( )),
# variable names are expanded to their values even without the '$'.
#
# Portability notes:
# - Assignment (=), conditional (expr?expr:expr) and comparison (==, <, etc.)
#   expressions, altough POSIX, are not supported in every current POSIX shell.
#   If you want to use them, check if 'thisshellhas FULLARITH' first.
# - bash, ksh and zsh do recursive evaluation of variable names (where a
#   variable can contain the name of another variable, and so forth), but that
#   is non-standard and unportable.
#
# Function:		Returns succcessfully if:
# --------		------------------------
# eq <expr> <expr>	the two expressions evaluate to the same number
# ne <expr> <expr>	the two expressions evaluate to different numbers
# lt <expr> <expr>	the 1st expr evaluates to a smaller number than the 2nd
# le <expr> <expr>	the 1st expr eval's to smaller than or equal to the 2nd
# gt <expr> <expr>	the 1st expr evaluates to a greater number than the 2nd
# ge <expr> <expr>	the 1st expr eval's to greater than or equal to the 2nd
#
# Example:
# if eq 2+2 4; then echo 'freedom granted; all else follows'; fi

# Test if the given argument is an integer number.
# Leading and trailing space and tab characters are ignored
# (because they are ignored in test/[ and shell arith as well).
isint() {
	[ "$#" -eq 1 ] || _Msh_dieArgs eq "$#" 1 || return
	_Msh_isint_V="${1#"${1%%[! $CCt]*}"}"
	_Msh_isint_V="${_Msh_isint_V%"${_Msh_isint_V##*[! $CCt]}"}"
	case "${_Msh_isint_V}" in
	( '' | *[!0123456789+-]* )
		unset -v _Msh_isint_V; return 1 ;;
	( [+-]* )
		;;
	( *[+-]* )
		unset -v _Msh_isint_V; return 1 ;;
	esac
	unset -v _Msh_isint_V
}

if thisshellhas FULLARITH; then
	# High performance variants for shells with full POSIX arith support.
	# The arith operator itself does sufficient validation on all shells,
	# though error messages are not always very clear.
	#
	# As a performance hack, the functions below abuse this arith
	# validation in combination with parameter substitution to check for
	# excess arguments, by injecting a guaranteed-to-be-invalid
	# value (starting with an escaped '\') in case of excess
	# arguments. According to my tests, this is completely reliable in
	# every shell, and causes no noticable performance reduction. Not
	# only that, many shells (not zsh or yash) helpfully insert the
	# invalid value into its own error message, so we can add our own
	# message ('excess arguments') to be passed on.
	#
	# Shells exit on arith evaluation errors, so the usual "|| die" is
	# ineffective and we can't terminate the program properly from a
	# subshell. I have made the choice that the performance gain is worth
	# it in this instance.
	#
	# Note: the inversion of comparison operators is NOT a bug! POSIX
	# arith is based on the C language, so uses 1 for true and 0 for
	# false, whereas the shell language itself does the inverse. The
	# fastest way to invert the result code is to invert the operators.
	eq() { return "$(((${1?eq: needs 2 arguments})!=(${2?eq: needs 2 arguments})${3+\\[ eq: excess arguments ]}))"; }
	ne() { return "$(((${1?ne: needs 2 arguments})==(${2?ne: needs 2 arguments})${3+\\[ ne: excess arguments ]}))"; }
	lt() { return "$(((${1?lt: needs 2 arguments})>=(${2?lt: needs 2 arguments})${3+\\[ lt: excess arguments ]}))"; }
	le() { return "$(((${1?le: needs 2 arguments})>(${2?le: needs 2 arguments})${3+\\[ le: excess arguments ]}))"; }
	gt() { return "$(((${1?gt: needs 2 arguments})<=(${2?gt: needs 2 arguments})${3+\\[ gt: excess arguments ]}))"; }
	ge() { return "$(((${1?ge: needs 2 arguments})<(${2?ge: needs 2 arguments})${3+\\[ ge: excess arguments ]}))"; }
else
	# Variants for shells with incomplete POSIX arith support. We rely
	# on POSIX arith evaluation to validate the arguments for '[', again
	# abusing parameter substitution to inject guaranteed-to-be-invalid
	# values in case of missing or excess arguments.
	# Shells exit on arith evaluation errors, so testing the exit status
	# of '[' is redundant.
	eq() { [ "$((${1?eq: needs 2 arguments}))" -eq "$((${2?eq: needs 2 arguments}${3+\\[ eq: excess arguments ]}))" ]; }
	ne() { [ "$((${1?ne: needs 2 arguments}))" -ne "$((${2?ne: needs 2 arguments}${3+\\[ ne: excess arguments ]}))" ]; }
	lt() { [ "$((${1?lt: needs 2 arguments}))" -lt "$((${2?lt: needs 2 arguments}${3+\\[ lt: excess arguments ]}))" ]; }
	le() { [ "$((${1?le: needs 2 arguments}))" -le "$((${2?le: needs 2 arguments}${3+\\[ le: excess arguments ]}))" ]; }
	gt() { [ "$((${1?gt: needs 2 arguments}))" -gt "$((${2?gt: needs 2 arguments}${3+\\[ gt: excess arguments ]}))" ]; }
	ge() { [ "$((${1?ge: needs 2 arguments}))" -ge "$((${2?ge: needs 2 arguments}${3+\\[ ge: excess arguments ]}))" ]; }
fi
	
# ---- String tests. ----
# (Negative string tests are not provided; just put 'not' or '!' before them)
# TODO: decide if testing for ['s exit status is necessary. Can it fail?

# Test for the empty string. Usage: empty <value>
#	Unlike "test -z", this function deals correctly with the POSIX
#	shell's non-optional removal of unquoted empty arguments: it accepts
#	zero arguments as equivalent to empty. That means, if you 'use safe',
#	you can do 'if empty $VAR' without having to quote $VAR, provided you
#	field splitting or globbing are not turned on.
#	The function treats more than one argument as a fatal error, because
#	that is a sign of unexpected field splitting or globbing.
#	(To be compatible with set -u (nounset), we have to avoid
#	accessing ${#1} (length of $1) if $1 is not set, so test $# first.)
empty() {
	[ "$#" -eq 0 ] && return
	[ "$#" -le 1 ] || _Msh_dieArgs empty "$#" '0 or 1' || return
	[ "${#1}" -eq 0 ]
}

# Test for identical strings. Usage: same <value1> <value2>
#	According to POSIX spec, there may still be some shells around
#	that misinterpret $1 if it starts with '-', '(', '!' or '=', so we
#	may need a protector character ('X' below).
#	I don't know if any of the more modern shells that modernish will
#	run on has this issue, but better safe than sorry.
same() {
	[ "$#" -eq 2 ] || _Msh_dieArgs same "$#" 2 || return
	[ "X$1" = "X$2" ]
}

# For lexical comparison, unfortunately [ '<' and '>' ] are not POSIX, but
# the standards-compliant way requires the external 'expr' utility. So let's
# see what this particular shell supports and fall back on 'expr', making
# sure that it works even if the arguments contain newline characters.

# ...	If we're running on bash, ksh or zsh:
if eval "[[ 'a${CCn}b' < 'a${CCn}bb' && 'a${CCn}bb' > 'a${CCn}b' ]]"
then
	sortsbefore() {
		[ "$#" -eq 2 ] || _Msh_dieArgs sortsbefore "$#" 2 || return
		[[ "$1" < "$2" ]]
	}
	sortsafter() {
		[ "$#" -eq 2 ] || _Msh_dieArgs sortsafter "$#" 2 || return
		[[ "$1" > "$2" ]]
	}
# ...	Try to fall back to builtin '['/'test' non-standard feature.
#	Thankfully, '<' and '>' are pretty widely supported for this
#	builtin. Unlike with [[ ]], we need to quote everything.
elif eval "[ 'a${CCn}b' '<' 'a${CCn}bb' ] && [ 'a${CCn}bb' '>' 'a${CCn}b' ]"
then
	sortsbefore() {
		[ "$#" -eq 2 ] || _Msh_dieArgs sortsbefore "$#" 2 || return
		[ "X$1" '<' "X$2" ] && return
		[ "$?" -gt 1 ] && die "sortsbefore: '[' failed"
	}
	sortsafter() {
		[ "$#" -eq 2 ] || _Msh_dieArgs sortsafter "$#" 2 || return
		[ "X$1" '>' "X$2" ] && return
		[ "$?" -gt 1 ] && die "sortsafter: ']' failed"
	}
# ...	Fall back to the POSIX way with 'expr'.
#	The test is paranoid to check that the utility is the one we
#	expect. These functions check for equal strings first to avoid an
#	unnecessary launch of an external processs.
elif eval "expr 1 = 1 && ! expr 1 = 2 \
	&& expr 'a${CCn}b' '<' 'a${CCn}bb' \
	&& expr 'a${CCn}bb' '>' 'a${CCn}b'"
then
	sortsbefore() {
		[ "$#" -eq 2 ] || _Msh_dieArgs sortsbefore "$#" 2 || return
		[ "X$1" = "X$2" ] && return 1
		expr "X$1" '<' "X$2" >/dev/null && return
		[ "$?" -gt 1 ] && die "sortsbefore: 'expr' failed"
	}
	sortsafter() {
		[ "$#" -eq 2 ] || _Msh_dieArgs sortsafter "$#" 2 || return
		[ "X$1" = "X$2" ] && return 1
		expr "X$1" '>' "X$2" >/dev/null && return
		[ "$?" -gt 1 ] && die "sortsafter: 'expr' failed"
	}
else
	printf '%s\n' "Can't run modernish: no valid 'expr' command available." 1>&3
	exit 127
fi 3>&2 >/dev/null 2>&1

# String comparison tests:
# Usage: <contains|startswith|endswith> <string> <string>
contains() {
	[ "$#" -eq 2 ] || _Msh_dieArgs contains "$#" 2 || return
	case "$1" in ( *"$2"* ) return 0 ;; esac
	return 1
}
startswith() {
	[ "$#" -eq 2 ] || _Msh_dieArgs startswith "$#" 2 || return
	case "$1" in ( "$2"* ) return 0 ;; esac
	return 1
}
endswith() {
	[ "$#" -eq 2 ] || _Msh_dieArgs endswith "$#" 2 || return
	case "$1" in ( *"$2" ) return 0 ;; esac
	return 1
}

# Glob pattern test:
# Usage: match <string> <globpattern>
#
# TODO:	Basic regex (match -b), extended regex (match -e) support.
#	If thisshellhas [[, use it.
#
# Unfortunately, many shells (zsh, ash, *ksh, ...) don't properly support
# passing a glob pattern with escaped characters from a variable. Escaping
# behaviour with glob patterns in variables varies wildly from shell to
# shell. Bash and dash follow the standard, but too many don't. To ensure
# portability, we must ban the \ from the glob pattern, and accept that
# escaping glob characters to match a literal '*', '?' or '[' using this
# function is impossible.
match() {
	[ "$#" -eq 2 ] || _Msh_dieArgs match "$#" 2 || return
	case "$2" in ( *\\* ) die 'match: Backslash-escaping is not supported.' || return ;; esac
	case "$1" in ( $2 ) return 0 ;; esac
	return 1
}


# --- General file tests. ---
# Note: These automatically resolve symlinks.
# TODO: decide whether they shouldn't, like file type tests.

# Test if file exists and is not an invalid symlink.
alias exists='_Msh_fileTest exists e -L'

# Test if file exists, is not an invalid symlink, and is non-empty. Unlike
# 'test -s', this also works for directories in which you have read
# permission. A race condition with tests like this is inevitable (even
# with the traditional 'test -s'). Be careful with parallel processing!
# Thanks to Stephane Chazelas for help with the directory testing code.
# Ref.: https://groups.google.com/forum/#!topic/comp.unix.shell/M_gDU9uk8Rk
isnonempty() {
	[ "$#" -eq 1 ] || _Msh_dieArgs isnonempty "$#" 1 || return
	if [ -d "$1" ] && [ -r "$1" ]; then
		(
			LC_ALL=C
			set +f
			cd -P -- "$1" && [ -r '.' ] || return 3
			set -- .* *
			{
				[ "$#" -eq 3 ] \
				&& [ "$1" = '.' ] \
				&& [ "$2" = '..' ] \
				&& [ "$3" = '*' ] \
				&& [ ! -L '*' ] \
				&& [ ! -e '*' ]
			} || {
				[ "$#" -eq 2 ] \
				&& [ "$1" = '.*' ] \
				&& [ ! -L '.*' ] \
				&& [ ! -e '.*' ] \
				&& [ "$2" = '*' ] \
				&& [ ! -L '*' ] \
				&& [ ! -e '*' ]
			}
			case "$?" in
			( 0 )	return 1 ;;
			( 1 )	return 0 ;;
			( * )	die "isnonempty: '[' failed" || return ;;
			esac
		)
	else
		_Msh_fileTest isnonempty s -L "$@"
	fi
}

# --- File permission tests. ---
# Note: These automatically resolve symlinks.
# TODO: decide whether they shouldn't, like file type tests.

# Test if this program can read, write or execute a file.
alias canread='_Msh_fileTest canread r -L'
alias canwrite='_Msh_fileTest canwrite w -L'
alias canexec='_Msh_fileTest canexec x -L'
	
# Test if file has user or group ID bits set.
alias issetuid='_Msh_fileTest issetuid u -L'
alias issetgid='_Msh_fileTest issetgid g -L'

# --- File type tests. ---

# Test if file is a symlink.
alias issymlink='_Msh_fileTest issymlink L -L'

# Note: The following tests do *not* resolve symlinks unless the -L option is
# used. This is to promote security and discourage allowing symlink attacks.

alias isblockspecial='_Msh_fileTest isblockspecial b'
alias ischarspecial='_Msh_fileTest ischarspecial c'
alias isdir='_Msh_fileTest isdir d'
alias isreg='_Msh_fileTest isreg f'
alias isfifo='_Msh_fileTest isfifo p'
alias issocket='_Msh_fileTest issocket S'

# Internal function. Not for direct use.
# (It is written to cope correctly with a file with the literal name '-L',
# without the need to add '--', even though -L is also an option. However,
# it will accept '--' out of respect for convention.)
_Msh_fileTest() {
	if [ "$#" -eq 3 ]; then
		[ "${#3}" -gt 0 ] || die "$1: empty string argument" || return
		[ ! -L "$3" ] && [ "-$2" "$3" ] && return
	elif [ "$#" -eq 4 ]; then
		[ "${#4}" -gt 0 ] || die "$1: empty string argument" || return
		case "$3" in
		( -L ) 	[ "-$2" "$4" ] && return ;;
		( -- ) 	[ ! -L "$4" ] && [ "-$2" "$4" ] && return ;;
		( -* )	die "$1: invalid option: $3" || return ;;
		( * )	die "$1: only one non-option argument allowed" || return ;;
		esac
	else
		_Msh_dieArgs "$1" "$(($#-2))" '1 or 2' || return
	fi
	[ "$?" -gt 1 ] && die "$1: '[' failed"
}

# Test if file descriptor is open and associated with a terminal.
#	Note: POSIX specifies that file descriptors can be 0 to minimum 19,
#	but most shells only support file descriptors between 0 and 9.
isonterminal() {
	[ "$#" -eq 1 ] || _Msh_dieArgs isonterminal "$#" 1 || return
	case "$1" in
	( *[!0123456789]* )
		die "isonterminal: invalid file descriptor: $1" ;;
	( * )	[ -t "$1" ] && return
		[ "$?" -gt 1 ] && die "isonterminal: '[' failed"
		;;
	esac
}

# -------------------

# Initialization, phase 2.

# --- Shell settings ---

# Figure out if we're on an interactive shell.
# (There are several different indications that our shell is interactive; be
# paranoid and test them all.)
if contains "$-" 'i' \
&& isonterminal 0 \
&& isonterminal 1 \
&& isonterminal 2 \
&& isset PS1
then
	MSH_INTERACTIVE=yes
else
	unset -v MSH_INTERACTIVE
fi
# On zsh, this incorrectly sets the var to the null string.
readonly MSH_INTERACTIVE

# Modernish does _not_ support -e (-o errexit); for many commands, we need
# to be able to distinguish between "false" (1) and "error" (2 or greater)
# exit status, but 'set -e' falsely considers any non-zero exit status to be
# an error. What exit status indicates error depends on the particular
# command. Modernish provides the 'harden' function to catch errors reliably
# on a command-by-command basis.
set +e	# the + means: turn it off (!)


# --- Set up the modernish environment ---

# Internal system constants.
# ...the directory of modernish modules
readonly _Msh_ModulesDir="$(cd "${ME%/*}/../libexec/modernish" && pwd -P)" \
|| exitwith 127 "modules directory not found"

# --- Embellishment aliases.
# These are to make the new shell language nicer to look at.
#	Aliases are expanded during pre-parsing, so they can't be used in
#	the same file that sets them. Sourcing works, though.

alias not='! '
alias so='[ "$?" -eq 0 ]' # test preceding command with 'if so;' or 'if not so;'

# bash and zsh have a much more readable synonym for '.'; make it universal.
if ! thisshellhas source; then
	alias source='.'
fi

# Print each argument on a separate line (unlike 'echo' which prints all
# arguments on one line). There is no processing of options or escape codes.
# NOTE: this is completely different from ksh/zsh 'print'.
if ! thisshellhas printf && thisshellhas print; then
	# This version is much faster on mksh, which has no builtin standard
	# 'printf' but does have a builtin ksh/zsh-style 'print'.
	#
	# (Don't make 'print' itself a function because, on shells where
	# modernish is already loaded and 'print' is already an alias,
	# '. modernish' would throw a syntax error if it's reloaded and
	# would not get a chance to print a graceful error message.)
	alias print='_Msh_doPrint'
	_Msh_doPrint() {
		command print -r -- "${1:-}"
		while [ "$#" -gt 1 ]; do
			command print -r -- "$2"
			shift
		done
	}
else
	# For most shells, use a simpe alias.
	alias print='printf %s\\n'
fi

# --------------------
# ------- MAIN -------
# --------------------

# Find out how modernish was invoked and launch the invoking program if necessary.
if ! endswith "$0" '/modernish'; then
	# modernish was sourced
	if isset MSH_INTERACTIVE; then
		readonly ME="modernish on $0"
		_Msh_Caps=''
		for _Msh_Cap in FULLARITH PIPEWOSUBSH RANDOM LINENO LOCAL \
			BUG_UPP BUG_MULTIBYTE BUG_FNSUBSH BUG_EVALRET BUG_READWHSP
		do
			if thisshellhas "${_Msh_Cap}"; then
				_Msh_Caps="${_Msh_Caps:-${CCn}This shell has:} ${_Msh_Cap}"
			fi
		done
		printf '%s\n' "Welcome to the modernish age (version $MSH_VERSION).${_Msh_Caps}"
		unset -v _Msh_Cap _Msh_Caps
		pushtrap "printf '\n%s\n' 'Exiting modernish $MSH_VERSION. Bye.'" EXIT
	else
		readonly ME="$0"
	fi
elif gt "$#" 0; then
	# modernish *is* the shell (e.g. '#!/usr/bin/env modernish'):
	# parse standard shell options
	while match "${1:-}" '[-+]*'; do
		case "$1" in
		( -c )
			_Msh_cmd="${1#-c}"
			if empty "${_Msh_cmd}"; then
				_Msh_cmd="$2"
				shift
			fi
			empty "${_Msh_cmd}" && exitwith 2 "option requires argument: -c"
			eval "${_Msh_cmd}"
			exit
			;;
		( -i | -l )
			_Msh_doExit 2 "To use modernish interactively, source it ('. modernish') in your shell profile."
			;;
		( [-+][abhmnvx] )
			set "$1" || _Msh_doExit "$?" "'set $1' failed"
			;;
		( --version )
			printf '%s\n' "$MSH_VERSION"
			exit
			;;
		( -- )
			shift
			break
			;;
		( * )
			_Msh_doExit 2 "invalid option: $1"
			;;
		esac
		shift
	done
	readonly ME="$1"
	shift
	# BUG_UPP workaround
	if gt "$#" 0; then
		. "$ME" "$@"
	else
		. "$ME"
	fi
else
	_Msh_doExit 2 "To use modernish interactively, source it ('. modernish') in your shell profile."
fi

# -------------

# As we're setting stuff to read-only, guard against initializing twice.
# (See 'if' at the top)
else

	case "${1:-}" in
	( --version )
		printf '%s\n' "$MSH_VERSION"
		;;
	( * )
		printf '%s\n' 'Modernish is already initialized. To reload it, exit this shell first.' 1>&2
		;;
	esac

fi
